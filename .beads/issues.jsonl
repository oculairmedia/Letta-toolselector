{"id":"lettatoolsselector-01y","title":"[Observability] Create Grafana dashboard for tool state","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T18:41:36.044718513Z","updated_at":"2025-12-28T15:52:31.007122757Z","comments":[{"id":60,"issue_id":"lettatoolsselector-01y","author":"node","text":"## Purpose\n\nGuard against regression where pagination is forgotten and only partial tools returned.\n\n## Test Scenario\n\n1. Mock Letta API to return 10 tools per page (3 pages total = 30 tools)\n2. Call list_agent_tools(agent_id)\n3. Assert: Returns all 30 tools\n4. Assert: Makes correct number of API calls\n\n## Acceptance Criteria\n\n- [ ] Test uses mocked responses (no real API)\n- [ ] Covers edge cases: 0 tools, exactly 1 page, multiple pages\n- [ ] Fails if fewer tools returned than expected\n- [ ] Runs in \u003c 1 second\n\n## Technical Notes\n\n- Use pytest-mock or responses library\n- Part of SDK test suite\n- Tag as \n\n---\nHuly Issue: LTSEL-21","created_at":"2025-12-23T18:41:36Z"}]}
{"id":"lettatoolsselector-06d","title":"[SDK] Migrate webhook-receiver to use shared SDK","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:26.226044359Z","updated_at":"2025-12-23T03:26:57.985147101Z","comments":[{"id":2,"issue_id":"lettatoolsselector-06d","author":"node","text":"## Problem\n\nWebhook receiver has its own tool management code that will drift from the SDK.\n\n## Solution\n\nReplace local implementations with SDK imports.\n\n## Acceptance Criteria\n\n- [ ] Add  to \n- [ ] Replace  functions with SDK imports\n- [ ] Replace  API calls with SDK helpers\n- [ ] All existing tests still pass\n- [ ] No functional changes to webhook behavior\n\n## Technical Notes\n\n- This is a refactor, not a feature change\n- May need to keep some webhook-specific wrappers\n\n---\nHuly Issue: LTSEL-5","created_at":"2025-12-22T23:46:26Z"}]}
{"id":"lettatoolsselector-07p","title":"[Observability] Add health check endpoint with tool state summary","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:09.047844161Z","updated_at":"2025-12-23T03:23:09.420110481Z","closed_at":"2025-12-23T03:23:09.420110481Z","close_reason":"Closed","comments":[{"id":33,"issue_id":"lettatoolsselector-07p","author":"node","text":"## Problem\n\nCurrent health endpoint only returns basic status. No way to quickly check if tool management is working correctly.\n\n## Solution\n\nEnhance health endpoint to include tool state summary.\n\n## Acceptance Criteria\n\n- [ ] Health endpoint returns: status, version, config summary\n- [ ] Include: MAX_TOTAL_TOOLS, PROTECTED_TOOLS list\n- [ ] Include: total_agents_tracked, agents_over_limit count\n- [ ] Include: last_attach_timestamp, last_prune_timestamp\n- [ ] Separate deep health check for dependencies (Letta API, Weaviate)\n\n## Technical Notes\n\n- Keep lightweight for frequent polling\n- Deep health check on separate endpoint (/health/deep)\n\n---\nHuly Issue: LTSEL-14","created_at":"2025-12-23T03:23:09Z"}]}
{"id":"lettatoolsselector-08q","title":"[Observability] Create Grafana dashboard for tool state","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-27T04:21:29.988244491Z","updated_at":"2025-12-27T04:21:29.988244491Z","comments":[{"id":220,"issue_id":"lettatoolsselector-08q","author":"root","text":"Synced from Beads: lettatoolsselector-9fs\n\n---\nHuly Issue: LTSEL-58","created_at":"2025-12-27T04:21:30Z"}]}
{"id":"lettatoolsselector-09g","title":"[SDK] Migrate tool-selector to use shared SDK","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:04.520360479Z","updated_at":"2025-12-23T03:23:04.874634818Z","closed_at":"2025-12-23T03:23:04.874634818Z","close_reason":"Closed","comments":[{"id":27,"issue_id":"lettatoolsselector-09g","author":"node","text":"## Problem\n\nTool selector has its own  and  that duplicate SDK functionality.\n\n## Solution\n\nReplace local implementations with SDK imports.\n\n## Acceptance Criteria\n\n- [ ] Add  to \n- [ ] Replace  helpers with SDK imports\n- [ ] Replace  with SDK imports\n- [ ] All existing tests still pass\n- [ ] No functional changes to tool selection behavior\n\n## Technical Notes\n\n- Worker service models may need adjustment\n- Keep API-specific logic in the repo, move generic logic to SDK\n\n---\nHuly Issue: LTSEL-6","created_at":"2025-12-23T03:23:04Z"}]}
{"id":"lettatoolsselector-0g6","title":"[SDK] Implement attach/detach tool helpers with retry logic","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:27.711027378Z","updated_at":"2025-12-23T03:27:00.609452772Z"}
{"id":"lettatoolsselector-14s","title":"[SDK] Migrate webhook-receiver to use shared SDK","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:03.941511875Z","updated_at":"2025-12-23T03:23:04.323825275Z","closed_at":"2025-12-23T03:23:04.323825275Z","close_reason":"Closed","comments":[{"id":26,"issue_id":"lettatoolsselector-14s","author":"node","text":"## Problem\n\nWebhook receiver has its own tool management code that will drift from the SDK.\n\n## Solution\n\nReplace local implementations with SDK imports.\n\n## Acceptance Criteria\n\n- [ ] Add  to \n- [ ] Replace  functions with SDK imports\n- [ ] Replace  API calls with SDK helpers\n- [ ] All existing tests still pass\n- [ ] No functional changes to webhook behavior\n\n## Technical Notes\n\n- This is a refactor, not a feature change\n- May need to keep some webhook-specific wrappers\n\n---\nHuly Issue: LTSEL-5","created_at":"2025-12-23T03:23:04Z"}]}
{"id":"lettatoolsselector-19c","title":"[Test] Contract test: Tool selector API returns valid response","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:28.355127429Z","updated_at":"2025-12-22T23:46:28.355127429Z","comments":[{"id":15,"issue_id":"lettatoolsselector-19c","author":"node","text":"## Purpose\n\nGuard against tool selector API returning unexpected response format.\n\n## Test Scenario\n\n1. Send valid attach request to tool selector API\n2. Capture response\n3. Assert: Response matches documented contract schema\n4. Assert: All required fields present (success, details.attached, details.detached)\n\n## Acceptance Criteria\n\n- [ ] Test validates response structure\n- [ ] Covers success and error responses\n- [ ] Fails if response doesn't match contract\n- [ ] Runs in tool-selector CI\n\n## Technical Notes\n\n- Can use real API or mocked\n- Reference contract from LTSEL-9\n- Tag as \n\n---\nHuly Issue: LTSEL-24","created_at":"2025-12-22T23:46:28Z"}]}
{"id":"lettatoolsselector-1vb","title":"[Test] Contract test: Webhook receiver sends valid attach payload","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:28.451265395Z","updated_at":"2025-12-22T23:46:28.451265395Z","comments":[{"id":16,"issue_id":"lettatoolsselector-1vb","author":"node","text":"## Purpose\n\nGuard against drift between webhook receiver and tool selector API contract.\n\n## Test Scenario\n\n1. Trigger webhook with known payload\n2. Capture the request sent to tool selector API\n3. Assert: Request matches documented contract schema\n4. Assert: All required fields present (agent_id, query, keep_tools)\n\n## Acceptance Criteria\n\n- [ ] Test validates payload structure, not behavior\n- [ ] Uses recorded/mocked tool selector response\n- [ ] Fails if payload doesn't match contract\n- [ ] Runs in webhook-receiver CI\n\n## Technical Notes\n\n- Use pytest with request capture (responses library)\n- Reference contract from LTSEL-9\n- Tag as \n\n---\nHuly Issue: LTSEL-23","created_at":"2025-12-22T23:46:28Z"}]}
{"id":"lettatoolsselector-1xa","title":"[Perf] Add connection wait with timeout to Weaviate pool","description":"## Problem\n`_acquire_connection()` raises exception immediately if no connections available instead of waiting.\n\n**Location:** `weaviate_client_manager.py:408-425`\n\n```python\n# Line 425\nraise Exception(\"No connections available in pool\")\n```\n\n## Impact\n- Under load, requests fail instead of queuing\n- **Priority:** LOW - only affects high concurrency\n\n## Solution\nImplement connection wait with timeout:\n\n```python\nasync def _acquire_connection(self, timeout: float = 5.0) -\u003e WeaviateConnection:\n    \"\"\"Acquire connection with wait timeout.\"\"\"\n    start = time.time()\n    \n    while time.time() - start \u003c timeout:\n        # Try to get available connection\n        for conn in self._pool:\n            if not conn.in_use:\n                conn.in_use = True\n                return conn\n        \n        # Wait briefly before retry\n        await asyncio.sleep(0.05)\n    \n    raise TimeoutError(f\"No connection available after {timeout}s\")\n```\n\n## Acceptance Criteria\n- [ ] Connections wait with configurable timeout\n- [ ] Timeout raises appropriate exception\n- [ ] Metrics for connection wait time\n- [ ] All unit tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-29T01:51:11.704316045Z","updated_at":"2025-12-29T01:51:11.704316045Z","labels":["performance"]}
{"id":"lettatoolsselector-24z","title":"[Test] Unit test: ensure_protected_tools attaches missing tools","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:17.158269365Z","updated_at":"2025-12-23T03:23:17.158269365Z","comments":[{"id":41,"issue_id":"lettatoolsselector-24z","author":"node","text":"## Purpose\n\nGuard against regression where protected tools logic fails silently.\n\n## Test Scenarios\n\n1. Agent has all protected tools -\u003e Returns already_present, no attach calls\n2. Agent missing find_agents -\u003e Attaches it, returns in attached list\n3. Tool ID lookup fails -\u003e Returns in failed list with reason\n4. Attach API fails -\u003e Returns in failed list with reason\n\n## Acceptance Criteria\n\n- [ ] All 4 scenarios covered\n- [ ] Uses mocked API responses\n- [ ] Verifies correct API calls made\n- [ ] Runs in \u003c 1 second\n\n## Technical Notes\n\n- Use pytest-mock\n- Part of SDK test suite\n- Tag as \n\n---\nHuly Issue: LTSEL-22","created_at":"2025-12-23T03:23:17Z"}]}
{"id":"lettatoolsselector-2a2","title":"[Test] Unit test: ensure_protected_tools attaches missing tools","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:27:59.540444503Z","updated_at":"2025-12-23T03:27:59.540444503Z","comments":[{"id":50,"issue_id":"lettatoolsselector-2a2","author":"node","text":"Synced from Beads: lettatoolsselector-e6b\n\n---\nHuly Issue: LTSEL-35","created_at":"2025-12-23T03:27:59Z"}]}
{"id":"lettatoolsselector-33d","title":"[Refactor] Migrate safety handlers to safety blueprint","description":"## Goal\nMove 3 safety-related handlers from api_server.py into routes/safety.py with full implementations.\n\n## Handlers to Migrate\n- _get_safety_status_handler() - Line 2388\n- _validate_operation_handler() - Line 2469\n- _get_emergency_status_handler() - Line 2514\n\n## Dependencies\nThese handlers interact with:\n- Safety/protection status utilities\n- Tool validation logic\n- Emergency mode state\n\n## Pattern\n1. Move handler implementations into safety.py blueprint\n2. Pass required dependencies via configure() method\n3. Remove old handlers from api_server.py\n\n## Acceptance Criteria\n- [ ] All 3 handlers removed from api_server.py\n- [ ] routes/safety.py contains full implementations\n- [ ] All unit tests pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T00:43:22.309752565Z","updated_at":"2025-12-29T01:06:15.70343165Z","closed_at":"2025-12-29T01:06:15.70343165Z","close_reason":"Closed","labels":["refactor","services-layer"]}
{"id":"lettatoolsselector-35e","title":"[Config] Add config validation to CI pipeline","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:19.20176836Z","updated_at":"2025-12-23T03:23:19.20176836Z","comments":[{"id":45,"issue_id":"lettatoolsselector-35e","author":"node","text":"## Problem\n\nInvalid config values (e.g., MAX_TOTAL_TOOLS \u003e MAX_MCP_TOOLS) can be deployed without warning.\n\n## Solution\n\nAdd CI job that validates configuration constraints.\n\n## Acceptance Criteria\n\n- [ ] CI job runs on every PR\n- [ ] Validates: MAX_TOTAL_TOOLS \u003c= MAX_MCP_TOOLS\n- [ ] Validates: MIN_MCP_TOOLS \u003c= MAX_TOTAL_TOOLS\n- [ ] Validates: PROTECTED_TOOLS contains valid tool names\n- [ ] Fails build with clear error message on invalid config\n\n## Technical Notes\n\n- Can be a simple Python script\n- Read from .env.example for defaults\n- Consider JSON schema for config validation\n\n---\nHuly Issue: LTSEL-16","created_at":"2025-12-23T03:23:19Z"}]}
{"id":"lettatoolsselector-3iy","title":"[Config] Consolidate .env files and compose configurations","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:07.521149427Z","updated_at":"2025-12-23T03:23:07.879876339Z","closed_at":"2025-12-23T03:23:07.879876339Z","close_reason":"Closed","comments":[{"id":31,"issue_id":"lettatoolsselector-3iy","author":"node","text":"## Problem\n\nTool selector has multiple compose files (compose.yaml, docker-compose.yml, compose-with-reranker.yaml) and an .env file. Changes require editing multiple places.\n\n## Solution\n\nConsolidate to single compose.yaml with environment-specific overrides via .env.\n\n## Acceptance Criteria\n\n- [ ] Single compose.yaml as source of truth\n- [ ] .env.example checked into repo with all variables documented\n- [ ] .env (not checked in) for local overrides\n- [ ] Remove deprecated docker-compose.yml\n- [ ] CI validates .env.example has all required vars\n\n## Technical Notes\n\n- Use compose profiles for optional services (reranker, etc.)\n- Document which vars are required vs optional\n- Add validation script to check env completeness\n\n---\nHuly Issue: LTSEL-15","created_at":"2025-12-23T03:23:07Z"}]}
{"id":"lettatoolsselector-3nw","title":"[Perf] Reuse Weaviate connection pool instead of creating client per search","description":"## Problem\nEach call to `search_tools_with_reranking()` creates a new Weaviate client via `init_client()`, including TCP/gRPC connection establishment.\n\n**Location:** `weaviate_tool_search_with_reranking.py:204-208, 331-335`\n\n```python\n# Line 204\nclient = init_client()  # Creates new client EVERY search!\n```\n\n## Impact\n- **Latency:** 50-200ms per search in connection overhead\n- **Priority:** CRITICAL - affects every search request\n\n## Solution\nUse the existing `WeaviateClientManager` connection pool from `weaviate_client_manager.py`:\n\n```python\nfrom weaviate_client_manager import get_client_manager\n\ndef search_tools_with_reranking(...):\n    manager = get_client_manager()\n    with manager.get_client() as client:\n        # perform search\n```\n\n## Acceptance Criteria\n- [ ] `search_tools()` uses connection pool\n- [ ] `search_tools_with_reranking()` uses connection pool\n- [ ] No new Weaviate clients created per request\n- [ ] Connection pool metrics logged on startup\n- [ ] All unit tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-29T01:49:05.951470743Z","updated_at":"2025-12-29T03:46:24.905526284Z","closed_at":"2025-12-29T03:46:24.905526284Z","close_reason":"Closed","labels":["performance"]}
{"id":"lettatoolsselector-418","title":"[Config] Create automated deploy script","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:18.823169301Z","updated_at":"2025-12-23T03:23:18.823169301Z","comments":[{"id":44,"issue_id":"lettatoolsselector-418","author":"node","text":"## Problem\n\nChanging config requires manual: edit .env, restart container, verify health. This is error-prone.\n\n## Solution\n\nCreate a deploy script that handles config updates safely.\n\n## Acceptance Criteria\n\n- [ ] Script:  to update and restart\n- [ ] Validates config before deploying\n- [ ] Backs up current .env before changes\n- [ ] Waits for health check after restart\n- [ ] Rolls back on health check failure\n- [ ] Logs all actions for audit\n\n## Technical Notes\n\n- Use docker compose up -d --force-recreate\n- Add --dry-run flag for testing\n- Consider GitHub Action for remote deploys\n\n---\nHuly Issue: LTSEL-17","created_at":"2025-12-23T03:23:19Z"}]}
{"id":"lettatoolsselector-46k","title":"[Code Quality] Fix type annotation errors in api_server.py","description":"The api_server.py file has 68+ type checking errors from Pyright/Pylance. These don't affect runtime but indicate code quality issues.\n\n## Main Categories of Errors\n\n### 1. None vs Expected Type\nFunctions return `None` but type hints expect a specific type:\n- Line 309: Expression of type 'None' cannot be assigned to parameter of type 'str'\n- Line 403: Expression of type 'None' cannot be assigned to parameter of type 'list'\n- Line 898, 978, 980, 1037: Similar None assignment issues\n\n### 2. Possibly Unbound Variables  \nVariables that might not be defined in all code paths:\n- Lines 255, 314, 369, 833, 854, 874: 'get_letta_sdk_client' is possibly unbound\n\n### 3. Function Signature Mismatches\nDeclared types don't match actual implementations:\n- Line 18: ConfigValidationResponse vs expected CoroutineType\n- Line 23: Multiple async function return type mismatches\n\n## Acceptance Criteria\n- [ ] All Pyright/Pylance errors resolved\n- [ ] Type hints accurately reflect actual function behavior  \n- [ ] No runtime behavior changes\n- [ ] Tests still pass","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-28T17:12:59.527538844Z","updated_at":"2025-12-28T17:12:59.527538844Z"}
{"id":"lettatoolsselector-4tm","title":"[SDK] Create letta-toolkit Python package scaffold","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:12.941728881Z","updated_at":"2025-12-23T03:23:13.332563419Z","closed_at":"2025-12-23T03:23:13.332563419Z","close_reason":"Closed","comments":[{"id":36,"issue_id":"lettatoolsselector-4tm","author":"node","text":"## Problem\n\nTool management logic is duplicated across webhook-receiver and tool-selector repos, causing drift and inconsistent behavior.\n\n## Solution\n\nCreate a shared Python package  that can be installed in both repos.\n\n## Acceptance Criteria\n\n- [ ] Package scaffold with  and proper versioning\n- [ ] Package published to private PyPI or installable via git+https\n- [ ] Basic CI/CD pipeline for testing and publishing\n- [ ] README with installation and usage instructions\n\n## Technical Notes\n\n- Use  layout for clean imports\n- Target Python 3.11+\n- Include type hints throughout\n\n---\nHuly Issue: LTSEL-1","created_at":"2025-12-23T03:23:13Z"}]}
{"id":"lettatoolsselector-4w9","title":"[Refactor] Phase 3: Extract service layer - SearchService","description":"Extract search and reranking logic into a dedicated SearchService.\n\n## Depends On\n- lettatoolsselector-869 (Phase 1: Extract models)\n\n## Functions to Extract\n\n### SearchService (`services/search_service.py`)\n\nMove/consolidate these:\n\n| Source | Function | Responsibility |\n|--------|----------|----------------|\n| api_server.py | `unified_tool_search()` | Unified search interface |\n| weaviate_tool_search_with_reranking.py | `search_tools()` | Weaviate search |\n| weaviate_tool_search_with_reranking.py | `search_tools_with_reranking()` | Search + rerank |\n\n### Interface\n```python\nclass SearchService:\n    def __init__(\n        self, \n        weaviate_client,\n        reranker_config: RerankerConfig,\n        expansion_config: ExpansionConfig\n    ):\n        self.weaviate = weaviate_client\n        self.reranker = reranker_config\n        self.expansion = expansion_config\n    \n    async def search(\n        self,\n        query: str,\n        limit: int = 10,\n        min_score: float = 0.0,\n        enable_reranking: bool = True,\n        enable_expansion: bool = True\n    ) -\u003e List[ToolSearchResult]:\n        ...\n    \n    async def rerank(\n        self,\n        query: str,\n        documents: List[str],\n        top_k: int = 10\n    ) -\u003e List[RerankResult]:\n        ...\n    \n    def expand_query(self, query: str) -\u003e ExpandedQuery:\n        ...\n```\n\n### Reranker Abstraction\n```python\nclass RerankerClient(Protocol):\n    async def rerank(self, query: str, documents: List[str], top_k: int) -\u003e List[RerankResult]:\n        ...\n\nclass VLLMReranker(RerankerClient):\n    # http://100.81.139.20:11435/v1/rerank\n    ...\n\nclass OllamaReranker(RerankerClient):\n    # http://ollama-reranker-adapter:8080/rerank\n    ...\n```\n\n## Acceptance Criteria\n- [ ] SearchService class created\n- [ ] Reranker abstraction with vLLM and Ollama implementations\n- [ ] Query expansion integrated\n- [ ] api_server.py uses SearchService\n- [ ] Unit tests for SearchService\n- [ ] Reranker can be swapped via config","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T19:37:39.506134951Z","updated_at":"2025-12-29T01:39:19.045598087Z"}
{"id":"lettatoolsselector-534","title":"[Perf] Queue audit events for async background processing","description":"## Problem\nAudit events are emitted synchronously in the request path, adding latency to every attach/prune operation.\n\n**Location:** `routes/tools.py:557-603, 700-754`\n\n```python\n# Line 557-603\nif _emit_batch_event_func and _audit_action_class and _audit_source_class:\n    # ... emit events synchronously ...\n```\n\n## Impact\n- **Latency:** 1-10ms per request\n- **Priority:** LOW-MEDIUM\n\n## Solution\nQueue audit events for background processing:\n\n```python\nimport asyncio\nfrom collections import deque\n\n_audit_queue: deque = deque(maxsize=10000)\n_audit_task: asyncio.Task = None\n\ndef queue_audit_event(event: dict):\n    \"\"\"Queue event for background processing.\"\"\"\n    try:\n        _audit_queue.append(event)\n    except:\n        logger.warning(\"Audit queue full, dropping event\")\n\nasync def _process_audit_queue():\n    \"\"\"Background task to process audit events.\"\"\"\n    while True:\n        if _audit_queue:\n            event = _audit_queue.popleft()\n            try:\n                await _emit_event_async(event)\n            except Exception as e:\n                logger.error(f\"Failed to emit audit event: {e}\")\n        else:\n            await asyncio.sleep(0.1)\n\nasync def start_audit_processor():\n    global _audit_task\n    _audit_task = asyncio.create_task(_process_audit_queue())\n```\n\n## Acceptance Criteria\n- [ ] Audit events queued instead of sync emission\n- [ ] Background task processes queue\n- [ ] Queue overflow handling (drop oldest or warn)\n- [ ] Graceful shutdown flushes queue\n- [ ] All unit tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-29T01:50:47.407351837Z","updated_at":"2025-12-29T01:50:47.407351837Z","labels":["performance"]}
{"id":"lettatoolsselector-5l3","title":"[Test] Contract test: Webhook receiver sends valid attach payload","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:16.775680432Z","updated_at":"2025-12-23T03:23:16.775680432Z","comments":[{"id":40,"issue_id":"lettatoolsselector-5l3","author":"node","text":"## Purpose\n\nGuard against drift between webhook receiver and tool selector API contract.\n\n## Test Scenario\n\n1. Trigger webhook with known payload\n2. Capture the request sent to tool selector API\n3. Assert: Request matches documented contract schema\n4. Assert: All required fields present (agent_id, query, keep_tools)\n\n## Acceptance Criteria\n\n- [ ] Test validates payload structure, not behavior\n- [ ] Uses recorded/mocked tool selector response\n- [ ] Fails if payload doesn't match contract\n- [ ] Runs in webhook-receiver CI\n\n## Technical Notes\n\n- Use pytest with request capture (responses library)\n- Reference contract from LTSEL-9\n- Tag as \n\n---\nHuly Issue: LTSEL-23","created_at":"2025-12-23T03:23:16Z"}]}
{"id":"lettatoolsselector-5vu","title":"[Config] Add config validation to CI pipeline","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:28:00.54116237Z","updated_at":"2025-12-23T03:28:00.54116237Z","comments":[{"id":53,"issue_id":"lettatoolsselector-5vu","author":"node","text":"Synced from Beads: lettatoolsselector-388\n\n---\nHuly Issue: LTSEL-31","created_at":"2025-12-23T03:28:00Z"}]}
{"id":"lettatoolsselector-5xn","title":"[Test] Integration test: Protected tools never detached","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:05.985338423Z","updated_at":"2025-12-23T03:23:06.372637179Z","closed_at":"2025-12-23T03:23:06.372637179Z","close_reason":"Closed","comments":[{"id":29,"issue_id":"lettatoolsselector-5xn","author":"node","text":"## Purpose\n\nRegression guard to ensure protected tools are never removed during pruning.\n\n## Test Scenario\n\n1. Create test agent with MAX_TOTAL_TOOLS tools including find_agents\n2. Trigger attachment that would require pruning\n3. Assert: find_agents is still attached after operation\n4. Repeat for each protected tool in PROTECTED_TOOLS list\n\n## Acceptance Criteria\n\n- [ ] Test runs in CI on every PR\n- [ ] Covers all configured protected tools\n- [ ] Fails if any protected tool is detached\n- [ ] Logs which tools were pruned vs preserved\n\n## Technical Notes\n\n- Parameterize test over PROTECTED_TOOLS list\n- Use pytest-parametrize for clean test output\n- Tag as \n\n---\nHuly Issue: LTSEL-20","created_at":"2025-12-23T03:23:06Z"}]}
{"id":"lettatoolsselector-626","title":"[Config] Document operational runbooks","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:28.787444478Z","updated_at":"2025-12-22T23:46:28.787444478Z","comments":[{"id":19,"issue_id":"lettatoolsselector-626","author":"node","text":"## Problem\n\nNo documentation for common ops tasks. Each debugging session rediscovers the same steps.\n\n## Solution\n\nCreate runbooks for common operations.\n\n## Acceptance Criteria\n\n- [ ] Runbook: How to change MAX_TOTAL_TOOLS limit\n- [ ] Runbook: How to add/remove protected tools\n- [ ] Runbook: How to manually prune an agent's tools\n- [ ] Runbook: How to debug \"tool not attaching\" issues\n- [ ] Runbook: How to check tool selector health\n- [ ] Store in docs/ directory within repo\n\n## Technical Notes\n\n- Include exact commands with expected outputs\n- Link to relevant compose services and env vars\n- Keep updated as architecture evolves\n\n---\nHuly Issue: LTSEL-18","created_at":"2025-12-22T23:46:28Z"}]}
{"id":"lettatoolsselector-642","title":"[Refactor] Phase 0: Establish test coverage for critical paths","description":"Before refactoring api_server.py (9,027 lines), we need test coverage on critical paths to ensure refactoring doesn't break functionality.\n\n## Critical Paths to Cover\n\n### Priority 1 - Core Tool Operations (Most Used)\n1. **POST /api/v1/tools/attach** (lines 1136-1455)\n   - Tool search and attachment flow\n   - Pre-attach pruning logic\n   - Loop trigger mechanism\n   - Webhook emission\n\n2. **POST /api/v1/tools/search** (lines 577-678)\n   - Weaviate search with reranking\n   - Query expansion\n   - Score filtering\n\n3. **POST /api/v1/tools/prune** (lines 1779-1888)\n   - Tool pruning logic\n   - MIN_MCP_TOOLS enforcement\n\n### Priority 2 - Supporting Functions\n4. `attach_tool()` / `detach_tool()` (lines 309-401)\n5. `process_tools()` (lines 403-575)\n6. `_perform_tool_pruning()` (lines 1483-1777)\n7. `trigger_agent_loop()` (lines 1037-1081)\n\n### Priority 3 - Cache \u0026 Agent Operations\n8. `read_tool_cache()` / `read_mcp_servers_cache()`\n9. `fetch_agent_info()` / `fetch_agent_tools()`\n\n## Current Coverage\n- Overall: 13%\n- api_server.py: 8.8%\n\n## Target Coverage Before Refactoring\n- Critical paths (Priority 1): 80%+\n- Supporting functions (Priority 2): 70%+\n- Cache operations (Priority 3): 60%+\n\n## Test Types Needed\n- [ ] Unit tests with mocked Letta/Weaviate clients\n- [ ] Integration tests against running services\n- [ ] Contract tests for API endpoints\n\n## Acceptance Criteria\n- [ ] Critical path coverage reaches 80%\n- [ ] All existing tests still pass\n- [ ] Test fixtures/mocks established for reuse","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-28T19:36:47.114061273Z","updated_at":"2025-12-28T23:09:18.959264439Z"}
{"id":"lettatoolsselector-6fh","title":"[Enforcement] Create scheduled agent tool pruning job","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:29.355653376Z","updated_at":"2025-12-22T23:46:29.355653376Z","comments":[{"id":24,"issue_id":"lettatoolsselector-6fh","author":"node","text":"## Problem\n\nIf no webhook runs for an agent, tools accumulate without being pruned. Need a background job to enforce limits.\n\n## Solution\n\nCreate a scheduled job that scans all agents and prunes any that exceed MAX_TOTAL_TOOLS.\n\n## Acceptance Criteria\n\n- [ ] Cron or Celery beat job runs daily\n- [ ] Fetches all agents from Letta API\n- [ ] For each agent exceeding limit, prune to MAX_TOTAL_TOOLS\n- [ ] Respects protected tools list\n- [ ] Logs all pruning actions with agent ID and tool names\n- [ ] Emits metrics for monitoring (agents_pruned, tools_removed)\n\n## Technical Notes\n\n- Run at low-traffic time (e.g., 3 AM)\n- Use batch operations for efficiency\n- Consider rate limiting to avoid overwhelming Letta API\n\n---\nHuly Issue: LTSEL-8","created_at":"2025-12-22T23:46:29Z"}]}
{"id":"lettatoolsselector-6he","title":"[Observability] Add Prometheus metrics to tool selector API","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:19.698941683Z","updated_at":"2025-12-23T03:23:19.698941683Z","comments":[{"id":46,"issue_id":"lettatoolsselector-6he","author":"node","text":"## Problem\n\nNo quantitative metrics for monitoring tool attachment operations.\n\n## Solution\n\nAdd Prometheus metrics endpoint to tool selector API.\n\n## Acceptance Criteria\n\n- [ ]  endpoint exposing Prometheus format\n- [ ] Counters: tools_attached_total, tools_detached_total, tools_pruned_total\n- [ ] Gauges: agent_tool_count (per agent), agents_over_limit\n- [ ] Histograms: attach_request_duration_seconds\n- [ ] Labels: agent_id (for per-agent breakdown)\n\n## Technical Notes\n\n- Use prometheus_client library\n- Expose on separate port or same API\n- Consider cardinality limits on agent_id label\n\n---\nHuly Issue: LTSEL-13","created_at":"2025-12-23T03:23:19Z"}]}
{"id":"lettatoolsselector-6io","title":"[Feature] Semantic Enrichment System for World-Class Retrieval","description":"## Overview\nImplement a multi-layer semantic enrichment system that uses Claude Sonnet (via Anthropic proxy) to generate semantically rich tool descriptions that dramatically improve search accuracy.\n\n## Key Components\n\n### 1. MCP Server Profiler\n- Analyzes all tools from each MCP server\n- Generates domain context, entity types, action verbs\n- Cached with hash-based change detection\n\n### 2. Tool Enricher  \n- Uses server profile context to enrich individual tools\n- Extracts action-entity pairs (e.g., 'create issue', 'delete file')\n- Generates use cases and semantic keywords\n\n### 3. Change Detection\n- Hash-based detection of MCP server changes\n- Only re-enriches when tools/descriptions change\n- Weekly forced refresh\n\n### 4. Weaviate Schema Updates\n- New fields: action_entities, semantic_keywords, server_domain, use_cases\n- Enhanced hybrid search with new query properties\n\n## Expected Impact\n- 'create issue' directly matches huly_issue_ops\n- 'project management' has high recall for huly_* tools\n- CRUD tools discoverable via any supported operation\n\n## Design Doc\nSee docs/SEMANTIC_ENRICHMENT_DESIGN.md\n\n## Implementation Phases\n1. MCP Server Profiler\n2. Tool Enricher\n3. Weaviate Schema Update\n4. Incremental Sync Integration\n5. Evaluation","status":"open","priority":1,"issue_type":"feature","created_at":"2025-12-29T03:26:52.205387601Z","updated_at":"2025-12-29T03:26:52.205387601Z","labels":["enhancement"]}
{"id":"lettatoolsselector-6jz","title":"[Observability] Create Grafana dashboard for tool state","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-27T04:21:42.059502963Z","updated_at":"2025-12-27T04:21:42.059502963Z","comments":[{"id":222,"issue_id":"lettatoolsselector-6jz","author":"root","text":"Synced from Beads: lettatoolsselector-7dj\n\n---\nHuly Issue: LTSEL-55","created_at":"2025-12-27T04:21:42Z"}]}
{"id":"lettatoolsselector-6sz","title":"[Config] Consolidate .env files and compose configurations","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:26.939734223Z","updated_at":"2025-12-23T03:26:59.127046738Z","comments":[{"id":7,"issue_id":"lettatoolsselector-6sz","author":"node","text":"## Problem\n\nTool selector has multiple compose files (compose.yaml, docker-compose.yml, compose-with-reranker.yaml) and an .env file. Changes require editing multiple places.\n\n## Solution\n\nConsolidate to single compose.yaml with environment-specific overrides via .env.\n\n## Acceptance Criteria\n\n- [ ] Single compose.yaml as source of truth\n- [ ] .env.example checked into repo with all variables documented\n- [ ] .env (not checked in) for local overrides\n- [ ] Remove deprecated docker-compose.yml\n- [ ] CI validates .env.example has all required vars\n\n## Technical Notes\n\n- Use compose profiles for optional services (reranker, etc.)\n- Document which vars are required vs optional\n- Add validation script to check env completeness\n\n---\nHuly Issue: LTSEL-15","created_at":"2025-12-22T23:46:26Z"}]}
{"id":"lettatoolsselector-6ti","title":"[Code Quality] Fix async function return type annotations","description":"Several async function decorators have mismatched return type annotations.\n\n## Affected Areas\n\n### Line 18 - Config validation\n```\nType '(config: Dict[str, Any]) -\u003e ConfigValidationResponse' is not assignable to declared type '() -\u003e CoroutineType[Any, Any, Response | tuple[Response, Literal[500]]]'\n```\n\n### Line 23 - Multiple tracking functions\n```\nType '(operation: str, token_count: int, provider: str = \"openai\") -\u003e CoroutineType[Any, Any, bool]' is not assignable to declared type '(...) -\u003e None'\n```\n\n## Root Cause\nDecorator type hints don't match the actual decorated function signatures.\n\n## Acceptance Criteria\n- [ ] All async function return types correctly annotated\n- [ ] Decorator types match decorated function signatures\n- [ ] Consider using ParamSpec for generic decorator typing","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-28T17:13:30.373745238Z","updated_at":"2025-12-28T17:13:30.373745238Z"}
{"id":"lettatoolsselector-784","title":"[Enforcement] Create scheduled agent tool pruning job","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:21.106579546Z","updated_at":"2025-12-23T03:23:21.106579546Z","comments":[{"id":48,"issue_id":"lettatoolsselector-784","author":"node","text":"## Problem\n\nIf no webhook runs for an agent, tools accumulate without being pruned. Need a background job to enforce limits.\n\n## Solution\n\nCreate a scheduled job that scans all agents and prunes any that exceed MAX_TOTAL_TOOLS.\n\n## Acceptance Criteria\n\n- [ ] Cron or Celery beat job runs daily\n- [ ] Fetches all agents from Letta API\n- [ ] For each agent exceeding limit, prune to MAX_TOTAL_TOOLS\n- [ ] Respects protected tools list\n- [ ] Logs all pruning actions with agent ID and tool names\n- [ ] Emits metrics for monitoring (agents_pruned, tools_removed)\n\n## Technical Notes\n\n- Run at low-traffic time (e.g., 3 AM)\n- Use batch operations for efficiency\n- Consider rate limiting to avoid overwhelming Letta API\n\n---\nHuly Issue: LTSEL-8","created_at":"2025-12-23T03:23:21Z"}]}
{"id":"lettatoolsselector-7rj","title":"[Config] Create automated deploy script","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:28:00.227878853Z","updated_at":"2025-12-23T03:28:00.227878853Z","comments":[{"id":52,"issue_id":"lettatoolsselector-7rj","author":"node","text":"Synced from Beads: lettatoolsselector-hmg\n\n---\nHuly Issue: LTSEL-32","created_at":"2025-12-23T03:28:00Z"}]}
{"id":"lettatoolsselector-7z8","title":"[Refactor] Migrate models handlers to models blueprint","description":"## Goal\nMove 4 models-related handlers from api_server.py into routes/models.py with full implementations.\n\n## Handlers to Migrate\n- _search_test_handler() - Line 1436\n- _get_embedding_models_handler() - Line 1527\n- _get_embedding_health_handler() - Line 1622\n- _get_reranker_models_handler() - Line 1765\n\n## Dependencies\nThese handlers interact with:\n- Embedding providers (Ollama, etc.)\n- Reranker configuration\n- Health check utilities\n\n## Pattern\n1. Move handler implementations into models.py blueprint\n2. Pass required dependencies via configure() method\n3. May reuse existing services (embedding_providers, etc.)\n4. Remove old handlers from api_server.py\n\n## Acceptance Criteria\n- [ ] All 4 handlers removed from api_server.py\n- [ ] routes/models.py contains full implementations\n- [ ] All unit tests pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T00:43:14.483667034Z","updated_at":"2025-12-29T01:10:44.00743334Z","closed_at":"2025-12-29T01:10:44.00743334Z","close_reason":"Closed","labels":["refactor","services-layer"]}
{"id":"lettatoolsselector-80x","title":"[Test] E2E test: Full webhook-to-attachment flow","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:14.296026908Z","updated_at":"2025-12-23T03:23:14.296026908Z","comments":[{"id":38,"issue_id":"lettatoolsselector-80x","author":"node","text":"## Purpose\n\nEnd-to-end smoke test that the entire pipeline works.\n\n## Test Scenario\n\n1. Create test agent in Letta\n2. Send message to agent (triggers webhook)\n3. Wait for webhook processing\n4. Assert: Agent has tools attached based on message content\n5. Assert: Agent tool count \u003c= MAX_TOTAL_TOOLS\n6. Assert: Protected tools present\n7. Cleanup test agent\n\n## Acceptance Criteria\n\n- [ ] Test uses real services (Letta, webhook, tool selector)\n- [ ] Runs nightly or on-demand (too slow for every PR)\n- [ ] Reports detailed failure info\n- [ ] Cleans up all test resources\n\n## Technical Notes\n\n- Use pytest with longer timeout\n- May need retry logic for async operations\n- Tag as \n- Run in isolated test environment if possible\n\n---\nHuly Issue: LTSEL-25","created_at":"2025-12-23T03:23:14Z"}]}
{"id":"lettatoolsselector-869","title":"[Refactor] Phase 1: Extract data models and types","description":"Extract data models, types, and constants from api_server.py into dedicated modules.\n\n## Depends On\n- lettatoolsselector-642 (Phase 0: Test coverage)\n\n## Models to Extract\n\n### 1. Tool Models (`models/tool.py`)\n```python\n@dataclass\nclass Tool:\n    id: str\n    name: str\n    description: str\n    tool_type: str  # 'external_mcp', 'custom', 'letta_core'\n    source_type: str\n    json_schema: dict\n    mcp_server_name: Optional[str]\n    tags: List[str]\n    \n@dataclass\nclass ToolAttachResult:\n    tool_id: str\n    tool_name: str\n    success: bool\n    error: Optional[str]\n\n@dataclass  \nclass ToolSearchResult:\n    tool: Tool\n    score: float\n    rerank_score: Optional[float]\n```\n\n### 2. Agent Models (`models/agent.py`)\n```python\n@dataclass\nclass AgentInfo:\n    id: str\n    name: str\n    \n@dataclass\nclass AgentToolSet:\n    agent_id: str\n    mcp_tools: List[Tool]\n    core_tools: List[Tool]\n    total_count: int\n```\n\n### 3. Request/Response Models (`models/requests.py`)\n```python\n@dataclass\nclass AttachRequest:\n    agent_id: str\n    query: str\n    limit: int = 10\n    min_score: float = 50.0\n    keep_tools: List[str] = field(default_factory=list)\n    skip_loop_trigger: bool = False\n\n@dataclass\nclass AttachResponse:\n    success: bool\n    message: str\n    successful_attachments: List[ToolAttachResult]\n    failed_attachments: List[ToolAttachResult]\n    detached_tools: List[str]\n    loop_triggered: bool\n```\n\n### 4. Constants (`constants.py`)\n```python\n# Tool limits\nDEFAULT_MAX_TOTAL_TOOLS = 30\nDEFAULT_MAX_MCP_TOOLS = 20\nDEFAULT_MIN_MCP_TOOLS = 7\nDEFAULT_DROP_RATE = 0.3\n\n# Letta core tool types\nLETTA_CORE_TOOL_TYPES = [\n    'letta_core', 'letta_voice_sleeptime_core', ...\n]\n\n# Never detach tools\nNEVER_DETACH_TOOLS = ['find_tools', 'matrix_messaging', ...]\n```\n\n## File Structure\n```\nlettaaugment-source/\n├── models/\n│   ├── __init__.py\n│   ├── tool.py\n│   ├── agent.py\n│   └── requests.py\n├── constants.py\n└── api_server.py (imports from above)\n```\n\n## Acceptance Criteria\n- [ ] All models extracted to dedicated files\n- [ ] Constants moved to constants.py\n- [ ] api_server.py imports from new modules\n- [ ] All tests still pass\n- [ ] No functional changes","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-28T19:37:09.269216431Z","updated_at":"2025-12-28T21:09:10.980552414Z","closed_at":"2025-12-28T21:09:10.980559948Z"}
{"id":"lettatoolsselector-8m5","title":"[SDK] Implement ensure_protected_tools helper","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:11.704019765Z","updated_at":"2025-12-23T03:23:11.910721455Z","closed_at":"2025-12-23T03:23:11.910721455Z","close_reason":"Closed"}
{"id":"lettatoolsselector-9kv","title":"[Test] Integration test: Tool count never exceeds MAX_TOTAL_TOOLS","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:26.807195814Z","updated_at":"2025-12-23T03:26:58.921635621Z","comments":[{"id":6,"issue_id":"lettatoolsselector-9kv","author":"node","text":"## Purpose\n\nRegression guard to ensure tool limits are enforced end-to-end.\n\n## Test Scenario\n\n1. Create test agent with MAX_TOTAL_TOOLS-1 tools attached\n2. Trigger webhook with query that matches 5 tools\n3. Assert: Agent tool count \u003c= MAX_TOTAL_TOOLS after operation\n4. Assert: Response includes pruned tools if any were removed\n\n## Acceptance Criteria\n\n- [ ] Test runs in CI on every PR\n- [ ] Uses real tool selector API (integration test)\n- [ ] Cleans up test agent after run\n- [ ] Fails if agent exceeds limit\n\n## Technical Notes\n\n- Use pytest with fixtures for agent setup/teardown\n- May need test-specific MAX_TOTAL_TOOLS value (e.g., 5) for fast testing\n- Tag as \n\n---\nHuly Issue: LTSEL-19","created_at":"2025-12-22T23:46:26Z"}]}
{"id":"lettatoolsselector-9ve","title":"[SDK] Implement ensure_protected_tools helper","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:27.837976718Z","updated_at":"2025-12-23T03:27:00.785021609Z"}
{"id":"lettatoolsselector-9x3","title":"[Test] E2E test: Full webhook-to-attachment flow","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:27:59.187579944Z","updated_at":"2025-12-23T03:27:59.187579944Z","comments":[{"id":49,"issue_id":"lettatoolsselector-9x3","author":"node","text":"Synced from Beads: lettatoolsselector-egf\n\n---\nHuly Issue: LTSEL-38","created_at":"2025-12-23T03:27:59Z"}]}
{"id":"lettatoolsselector-9yr","title":"[Refactor] Extract config module for tool limits","description":"## Summary\nExtract tool limit configuration into a dedicated config module to support service layer extraction.\n\n## Current Location\n- `api_server.py:129-154` (MAX_TOTAL_TOOLS, MAX_MCP_TOOLS, MANAGE_ONLY_MCP_TOOLS, NEVER_DETACH_TOOLS, etc.)\n\n## Proposed Location\n- `config/tool_limits.py` or add to existing `models.py`\n\n## Values to Extract\n```python\nMAX_TOTAL_TOOLS = int(os.getenv('MAX_TOTAL_TOOLS', '30'))\nMAX_MCP_TOOLS = int(os.getenv('MAX_MCP_TOOLS', '20'))\nMIN_MCP_TOOLS = int(os.getenv('MIN_MCP_TOOLS', '7'))\nMANAGE_ONLY_MCP_TOOLS = os.getenv('MANAGE_ONLY_MCP_TOOLS', 'false').lower() == 'true'\nNEVER_DETACH_TOOLS = [...]\n```\n\n## Implementation\n1. Create dataclass/Pydantic model for ToolLimitConfig\n2. Add to models.py or new config module\n3. Update tool_manager.configure() to accept config\n4. Update api_server.py to use centralized config\n\n## Acceptance Criteria\n- [ ] Config values centralized\n- [ ] tool_manager uses config object\n- [ ] api_server.py updated\n- [ ] Tests pass\n\n## Parent Issue\nlettatoolsselector-nav","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T20:51:49.575697277Z","updated_at":"2025-12-29T01:39:11.940266486Z"}
{"id":"lettatoolsselector-a3a","title":"[Perf] Cache MCP servers data in memory","description":"## Problem\nHealth check reads MCP servers cache via async file I/O on every request.\n\n**Location:** `api_server.py:823-835`\n\n```python\n# Line 828-830\nasync with aiofiles.open(MCP_SERVERS_CACHE_FILE_PATH, 'r') as f:\n    mcp_data = json.loads(await f.read())\n    mcp_servers_cache_size_on_disk = len(mcp_data)\n```\n\n## Impact\n- **Latency:** 5-50ms per health check in file I/O\n- **Priority:** MEDIUM - health checks are frequent\n\n## Solution\nCache MCP servers data in memory with TTL, similar to tool cache:\n\n```python\n_mcp_servers_cache: List[dict] = []\n_mcp_servers_cache_mtime: float = 0\n\nasync def read_mcp_servers_cache(force_reload=False) -\u003e List[dict]:\n    global _mcp_servers_cache, _mcp_servers_cache_mtime\n    \n    if not force_reload and _mcp_servers_cache:\n        # Check if file changed\n        current_mtime = os.path.getmtime(MCP_SERVERS_CACHE_FILE_PATH)\n        if current_mtime == _mcp_servers_cache_mtime:\n            return _mcp_servers_cache\n    \n    # Load from file\n    async with aiofiles.open(MCP_SERVERS_CACHE_FILE_PATH, 'r') as f:\n        _mcp_servers_cache = json.loads(await f.read())\n        _mcp_servers_cache_mtime = os.path.getmtime(MCP_SERVERS_CACHE_FILE_PATH)\n    \n    return _mcp_servers_cache\n```\n\n## Acceptance Criteria\n- [ ] MCP servers cached in memory\n- [ ] Cache invalidated on file mtime change\n- [ ] Health check uses cached data\n- [ ] All unit tests pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T01:50:20.792232309Z","updated_at":"2025-12-29T04:09:39.214648546Z","closed_at":"2025-12-29T04:09:39.214648546Z","close_reason":"Closed","labels":["performance"]}
{"id":"lettatoolsselector-a6c","title":"[Refactor] Add search_tools callback to tool_manager","description":"## Summary\nAdd `search_tools` as a configurable callback in `tool_manager.py` to support `_perform_tool_pruning` extraction.\n\n## Problem\n`_perform_tool_pruning` calls `search_tools()` which is imported from `weaviate_tool_search_with_reranking.py`. We can't import this directly in tool_manager without creating circular dependencies.\n\n## Solution\nAdd search function as a callback in `tool_manager.configure()`:\n\n```python\ndef configure(\n    http_session=None,\n    letta_url=None,\n    headers=None,\n    use_letta_sdk=False,\n    get_letta_sdk_client_func=None,\n    search_tools_func=None,  # NEW: callback for search\n    tool_config=None         # NEW: ToolLimitConfig\n):\n    ...\n```\n\n## Implementation\n1. Add `search_tools_func` parameter to `configure()`\n2. Store as module-level `_search_tools`\n3. Update api_server.py startup to pass `search_tools` function\n4. Add unit tests with mock search function\n\n## Acceptance Criteria\n- [ ] configure() accepts search_tools_func\n- [ ] api_server.py passes search_tools on startup\n- [ ] Tests pass with mock search\n\n## Parent Issue\nlettatoolsselector-nav","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T20:52:01.134499169Z","updated_at":"2025-12-29T01:26:08.016621812Z"}
{"id":"lettatoolsselector-b1t","title":"[Enforcement] Define and document auto-attachment contract","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:08.070788495Z","updated_at":"2025-12-23T03:23:08.431030137Z","closed_at":"2025-12-23T03:23:08.431030137Z","close_reason":"Closed","comments":[{"id":32,"issue_id":"lettatoolsselector-b1t","author":"node","text":"## Problem\n\nWebhook receiver and tool selector have different ideas about what fields are required, what keep_tools means, and how limits work.\n\n## Solution\n\nDefine a formal contract (JSON schema or Pydantic model) that both sides adhere to.\n\n## Acceptance Criteria\n\n- [ ] Document payload schema: query, agent_id, keep_tools, limit, min_score, protected_tools\n- [ ] Document response schema: success, attached, detached, preserved, errors\n- [ ] Document behavior: what happens when limits are exceeded, how protected tools work\n- [ ] Version the contract (v1) to allow future evolution\n- [ ] Both repos reference the same contract documentation\n\n## Technical Notes\n\n- Consider using OpenAPI/Swagger for formal spec\n- Publish contract in shared docs location or SDK repo\n\n---\nHuly Issue: LTSEL-9","created_at":"2025-12-23T03:23:08Z"}]}
{"id":"lettatoolsselector-b8l","title":"[SDK] Implement attach/detach tool helpers with retry logic","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:11.316159731Z","updated_at":"2025-12-23T03:23:11.516214876Z","closed_at":"2025-12-23T03:23:11.516214876Z","close_reason":"Closed"}
{"id":"lettatoolsselector-bhm","title":"[Test] Integration test: Protected tools never detached","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:26.661060325Z","updated_at":"2025-12-23T03:26:58.657641521Z","comments":[{"id":5,"issue_id":"lettatoolsselector-bhm","author":"node","text":"## Purpose\n\nRegression guard to ensure protected tools are never removed during pruning.\n\n## Test Scenario\n\n1. Create test agent with MAX_TOTAL_TOOLS tools including find_agents\n2. Trigger attachment that would require pruning\n3. Assert: find_agents is still attached after operation\n4. Repeat for each protected tool in PROTECTED_TOOLS list\n\n## Acceptance Criteria\n\n- [ ] Test runs in CI on every PR\n- [ ] Covers all configured protected tools\n- [ ] Fails if any protected tool is detached\n- [ ] Logs which tools were pruned vs preserved\n\n## Technical Notes\n\n- Parameterize test over PROTECTED_TOOLS list\n- Use pytest-parametrize for clean test output\n- Tag as \n\n---\nHuly Issue: LTSEL-20","created_at":"2025-12-22T23:46:26Z"}]}
{"id":"lettatoolsselector-c05","title":"[Refactor] Extract _perform_tool_pruning to tool_manager","description":"## Summary\nMove `_perform_tool_pruning` function from `api_server.py` to `tool_manager.py`.\n\n## Current Location\n- `api_server.py:1228-1521` (~300 lines)\n\n## Dependencies (must be resolved first)\n1. **lettatoolsselector-pmp**: Extract `fetch_agent_tools` to tool_manager\n2. **lettatoolsselector-9yr**: Extract config module for tool limits\n3. **lettatoolsselector-a6c**: Add `search_tools` callback to tool_manager\n\n## Function Signature\n```python\nasync def perform_tool_pruning(\n    agent_id: str,\n    user_prompt: str,\n    drop_rate: float,\n    keep_tool_ids: list = None,\n    newly_matched_tool_ids: list = None\n) -\u003e dict:\n```\n\n## Internal Dependencies (already in tool_manager)\n- `detach_tool()` - already extracted\n- `is_letta_core_tool()` - already in models.py\n\n## Implementation\n1. Complete prerequisite issues\n2. Move function to tool_manager.py\n3. Update api_server.py to delegate\n4. Update tests in test_tool_management.py to use tool_manager.configure()\n5. Add dedicated tests in test_tool_manager.py\n\n## Acceptance Criteria\n- [ ] Prerequisites completed\n- [ ] Function moved to tool_manager.py\n- [ ] api_server.py delegates to tool_manager\n- [ ] All 296+ unit tests pass\n- [ ] Integration tests pass\n\n## Parent Issue\nlettatoolsselector-nav","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T20:52:19.997470978Z","updated_at":"2025-12-29T01:26:07.817405967Z"}
{"id":"lettatoolsselector-c1l","title":"[Perf] Eliminate redundant isLettaCoreTool checks in attach loop","description":"## Problem\nSame `_is_letta_core_tool()` check is performed twice for the same tools - once for counting, once in the loop.\n\n**Location:** `routes/tools.py:382-390`\n\n```python\n# Counting - checks every tool\nmcp_count = len([t for t in current_agent_tools \n               if (t.get(\"tool_type\") == \"external_mcp\" or \n                   (not _is_letta_core_tool(t) and t.get(\"tool_type\") == \"custom\"))])\n\n# Loop - checks same tools again\nfor tool in current_agent_tools:\n    is_mcp_tool = (tool.get(\"tool_type\") == \"external_mcp\" or \n                 (not _is_letta_core_tool(tool) and tool.get(\"tool_type\") == \"custom\"))\n```\n\n## Impact\n- **Latency:** ~0.1ms per tool (duplicate function calls)\n- **Priority:** LOW\n\n## Solution\nCompute once and store results:\n\n```python\n# Compute MCP status once per tool\nmcp_status = {}\nfor tool in current_agent_tools:\n    tool_id = tool.get('id') or tool.get('tool_id')\n    is_mcp = (tool.get(\"tool_type\") == \"external_mcp\" or \n              (not _is_letta_core_tool(tool) and tool.get(\"tool_type\") == \"custom\"))\n    mcp_status[tool_id] = is_mcp\n\nmcp_count = sum(1 for is_mcp in mcp_status.values() if is_mcp)\n\n# Later in loop\nfor tool in current_agent_tools:\n    tool_id = tool.get('id') or tool.get('tool_id')\n    if mcp_status.get(tool_id):\n        # ... process MCP tool ...\n```\n\n## Acceptance Criteria\n- [ ] Each tool checked only once\n- [ ] MCP status cached for reuse\n- [ ] All unit tests pass","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-29T01:51:26.059923Z","updated_at":"2025-12-29T01:51:26.059923Z","labels":["performance"]}
{"id":"lettatoolsselector-cfc","title":"[Observability] Create Grafana dashboard for tool state","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-27T04:23:26.191104731Z","updated_at":"2025-12-27T05:15:40.413727767Z","comments":[{"id":223,"issue_id":"lettatoolsselector-cfc","author":"root","text":"Synced from Beads: lettatoolsselector-yie\n\n---\nHuly Issue: LTSEL-29","created_at":"2025-12-27T04:23:26Z"}]}
{"id":"lettatoolsselector-cvy","title":"[Observability] Emit structured events for tool attach/detach","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:05.071719446Z","updated_at":"2025-12-23T03:23:05.419749054Z","closed_at":"2025-12-23T03:23:05.419749054Z","close_reason":"Closed","comments":[{"id":28,"issue_id":"lettatoolsselector-cvy","author":"node","text":"## Problem\n\nNo audit trail for tool changes. Debugging requires scraping logs from multiple containers.\n\n## Solution\n\nEmit structured events to a queue/stream whenever tools are attached or detached.\n\n## Acceptance Criteria\n\n- [ ] Event schema: {timestamp, agent_id, tool_id, tool_name, action, reason, source}\n- [ ] Events emitted from tool selector API on every attach/detach\n- [ ] Events written to Redis Stream or similar (low overhead)\n- [ ] Events include correlation ID for tracing webhook -\u003e attach flow\n\n## Technical Notes\n\n- Use Redis Streams for simplicity (XADD)\n- Keep 7 days of events by default\n- Consider also writing to structured log for Loki ingestion\n\n---\nHuly Issue: LTSEL-11","created_at":"2025-12-23T03:23:05Z"}]}
{"id":"lettatoolsselector-d0t","title":"[SDK] Implement list_agent_tools with full pagination","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:12.533425716Z","updated_at":"2025-12-23T03:23:12.739214321Z","closed_at":"2025-12-23T03:23:12.739214321Z","close_reason":"Closed"}
{"id":"lettatoolsselector-d8b","title":"[Perf] Cache environment-based config at startup","description":"## Problem\nConfig endpoints parse environment variables on every request.\n\n**Location:** `routes/config.py:60-77, 135-151, 305-340`\n\n```python\n# Line 65-71\nconfig = {\n    \"enabled\": os.getenv('RERANKER_ENABLED', 'true').lower() == 'true',\n    \"model\": os.getenv('RERANKER_MODEL', 'qwen3-reranker-4b'),\n    ...\n}\n```\n\n## Impact\n- **Latency:** 0.5ms per config request\n- **Priority:** LOW\n\n## Solution\nCache config values at startup, only reload on explicit refresh:\n\n```python\n_cached_config: dict = None\n_config_loaded_at: float = 0\n\ndef _load_config() -\u003e dict:\n    return {\n        \"reranker\": {\n            \"enabled\": os.getenv('RERANKER_ENABLED', 'true').lower() == 'true',\n            \"model\": os.getenv('RERANKER_MODEL', 'qwen3-reranker-4b'),\n            # ...\n        },\n        \"weaviate\": {\n            # ...\n        }\n    }\n\ndef get_cached_config() -\u003e dict:\n    global _cached_config, _config_loaded_at\n    if _cached_config is None:\n        _cached_config = _load_config()\n        _config_loaded_at = time.time()\n    return _cached_config\n\ndef refresh_config():\n    global _cached_config\n    _cached_config = _load_config()\n```\n\n## Acceptance Criteria\n- [ ] Config parsed once at startup\n- [ ] Cached config used for read requests\n- [ ] Explicit refresh endpoint to reload config\n- [ ] All unit tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-29T01:51:01.443245463Z","updated_at":"2025-12-29T01:51:01.443245463Z","labels":["performance"]}
{"id":"lettatoolsselector-dai","title":"[Refactor] Migrate tools attach/prune/sync/refresh handlers to services pattern","description":"Move remaining tools handlers from api_server.py into routes/tools.py using the services layer pattern.\n\n## Handlers to Migrate\n- _tools_attach_handler (~320 lines) - attaches tools to agents\n- _tools_prune_handler (~100 lines) - prunes excess tools  \n- _tools_sync_handler (~15 lines) - syncs tool cache\n- _tools_refresh_handler (~10 lines) - refreshes tool cache\n\n## New Services Required\n- services/agent.py - AgentService wrapping fetch_agent_info, fetch_agent_tools\n- services/letta_client.py - LettaClientService wrapping SDK operations\n\n## Pattern\n1. Create new service files with DI pattern\n2. Move handler implementations into routes/tools.py\n3. Configure services in startup()\n4. Remove old handlers from api_server.py\n5. Update any tests mocking api_server to mock services\n\n## Estimated Reduction\n~450 lines removed from api_server.py","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T00:41:37.690094322Z","updated_at":"2025-12-29T03:46:17.563876412Z","closed_at":"2025-12-29T03:46:17.563876412Z","close_reason":"Closed","labels":["refactor","services-layer"]}
{"id":"lettatoolsselector-fv0","title":"[Perf] Add TTL cache for search results","description":"## Problem\nNo caching of search results. Identical queries within seconds hit Weaviate and reranker every time.\n\n**Location:** `services/tool_search.py`, `weaviate_tool_search_with_reranking.py`\n\n## Impact\n- **Latency:** 200-1000ms for repeated identical queries\n- **Priority:** HIGH - significant win for common query patterns\n\n## Solution\nAdd TTL-based cache for search results (60-300 seconds):\n\n```python\nfrom cachetools import TTLCache\n\n_search_cache = TTLCache(maxsize=1000, ttl=60)\n\ndef search_tools(query: str, limit: int = 10, reranker_config: dict = None):\n    # Create cache key from query params\n    cache_key = f\"{query}:{limit}:{hash(str(reranker_config))}\"\n    \n    if cache_key in _search_cache:\n        logger.debug(f\"Cache hit for query: {query}\")\n        return _search_cache[cache_key]\n    \n    # ... perform search ...\n    \n    _search_cache[cache_key] = results\n    return results\n```\n\n## Configuration\n- TTL configurable via env var `SEARCH_CACHE_TTL_SECONDS` (default: 60)\n- Max size configurable via `SEARCH_CACHE_MAX_SIZE` (default: 1000)\n- Add cache stats to health endpoint\n\n## Acceptance Criteria\n- [ ] Search results cached with configurable TTL\n- [ ] Cache key includes query, limit, and reranker config\n- [ ] Cache stats available in health/metrics endpoint\n- [ ] Cache can be cleared via API or on tool index refresh\n- [ ] All unit tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-29T01:49:42.255551437Z","updated_at":"2025-12-29T03:51:25.802220361Z","closed_at":"2025-12-29T03:51:25.802220361Z","close_reason":"Closed","labels":["performance"]}
{"id":"lettatoolsselector-fvk","title":"[Code Quality] Add Optional type hints for nullable parameters","description":"Several functions accept None values but lack proper Optional[] type hints.\n\n## Affected Functions\n\n### _emit_matrix_bridge_webhook (line 976-980)\nParameters that can be None but aren't typed as Optional:\n- `new_run_id: str = None` should be `new_run_id: Optional[str] = None`\n- `tool_names: list = None` should be `tool_names: Optional[List[str]] = None`\n- `query: str = None` should be `query: Optional[str] = None`\n\n### _send_trigger_message (line 898)\n- Similar nullable parameter issues\n\n### Other locations\n- Line 1514: list parameter that can be None\n\n## Acceptance Criteria\n- [ ] Import Optional from typing module where needed\n- [ ] Update all nullable parameters to use Optional[T]\n- [ ] Ensure default values match the Optional typing\n- [ ] No runtime behavior changes","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-28T17:13:10.07216349Z","updated_at":"2025-12-28T17:13:10.07216349Z"}
{"id":"lettatoolsselector-hhl","title":"[SDK] Create letta-toolkit Python package scaffold","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:28.031316453Z","updated_at":"2025-12-23T03:27:01.2274054Z","comments":[{"id":12,"issue_id":"lettatoolsselector-hhl","author":"node","text":"## Problem\n\nTool management logic is duplicated across webhook-receiver and tool-selector repos, causing drift and inconsistent behavior.\n\n## Solution\n\nCreate a shared Python package  that can be installed in both repos.\n\n## Acceptance Criteria\n\n- [ ] Package scaffold with  and proper versioning\n- [ ] Package published to private PyPI or installable via git+https\n- [ ] Basic CI/CD pipeline for testing and publishing\n- [ ] README with installation and usage instructions\n\n## Technical Notes\n\n- Use  layout for clean imports\n- Target Python 3.11+\n- Include type hints throughout\n\n---\nHuly Issue: LTSEL-1","created_at":"2025-12-22T23:46:28Z"}]}
{"id":"lettatoolsselector-ier","title":"[Refactor] Phase 6: Dependency injection and app factory","description":"Implement dependency injection and Flask app factory pattern for testability.\n\n## Depends On\n- lettatoolsselector-sbw (Phase 5: Route blueprints)\n\n## Goals\n1. Make services injectable for testing\n2. Create app factory for different configurations\n3. Establish clear initialization order\n\n## Implementation\n\n### App Factory (`app.py`)\n```python\ndef create_app(config: AppConfig = None) -\u003e Flask:\n    app = Flask(__name__)\n    \n    # Load config\n    config = config or load_config_from_env()\n    app.config.from_object(config)\n    \n    # Initialize clients\n    weaviate_client = init_weaviate(config.weaviate)\n    letta_client = init_letta(config.letta)\n    reranker_client = init_reranker(config.reranker)\n    \n    # Initialize services\n    search_service = SearchService(weaviate_client, reranker_client)\n    agent_service = AgentService(letta_client, config.webhook_url)\n    tool_manager = ToolManager(letta_client, weaviate_client, search_service)\n    \n    # Store in app context\n    app.services = ServiceContainer(\n        search=search_service,\n        agent=agent_service,\n        tools=tool_manager\n    )\n    \n    # Register blueprints\n    from routes import tools_bp, config_bp, health_bp, ...\n    app.register_blueprint(tools_bp)\n    app.register_blueprint(config_bp)\n    ...\n    \n    return app\n```\n\n### Service Container\n```python\n@dataclass\nclass ServiceContainer:\n    search: SearchService\n    agent: AgentService\n    tools: ToolManager\n    cache: CacheService\n    \ndef get_services() -\u003e ServiceContainer:\n    return current_app.services\n```\n\n### Route Handler Pattern\n```python\n@tools_bp.route('/attach', methods=['POST'])\nasync def attach_tools():\n    services = get_services()\n    request_data = AttachRequest.from_json(request.json)\n    \n    result = await services.tools.attach_tools_for_query(\n        agent_id=request_data.agent_id,\n        query=request_data.query,\n        ...\n    )\n    \n    return jsonify(result.to_dict())\n```\n\n### Testing Pattern\n```python\ndef test_attach_tools():\n    # Create mock services\n    mock_tool_manager = MockToolManager()\n    mock_tool_manager.attach_tools_for_query.return_value = AttachResponse(...)\n    \n    # Create app with mocks\n    app = create_app(config=TestConfig())\n    app.services.tools = mock_tool_manager\n    \n    # Test\n    with app.test_client() as client:\n        response = client.post('/api/v1/tools/attach', json={...})\n        assert response.status_code == 200\n```\n\n## Acceptance Criteria\n- [ ] App factory pattern implemented\n- [ ] ServiceContainer holds all services\n- [ ] Routes use get_services() helper\n- [ ] Tests can inject mock services\n- [ ] Configuration is centralized\n- [ ] All tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T19:38:36.125814136Z","updated_at":"2025-12-29T01:39:20.852627596Z"}
{"id":"lettatoolsselector-jh3","title":"[Perf] Use dict-based O(1) lookup for tool filtering","description":"## Problem\n`_filter_mcp_results()` performs O(n*m) linear search looking up each result in the tools cache.\n\n**Location:** `routes/tools.py:144-168`\n\n```python\n# Line 150 - O(n) lookup per result\ncached_tool = next((t for t in tools_cache if t.get('name') == tool_name), None)\n```\n\n## Impact\n- **Latency:** 10-50ms with 500+ tools in cache and 50 results (25,000+ comparisons)\n- **Priority:** MEDIUM-HIGH - easy fix with good payoff\n\n## Solution\nConvert `tools_cache` to a dictionary keyed by name at cache load time:\n\n```python\n# In ToolCacheService or at cache load time\n_tool_cache_by_name: Dict[str, dict] = {}\n\nasync def read_tool_cache(self, force_reload=False):\n    tools = await self._load_cache()\n    self._tool_cache_by_name = {t.get('name'): t for t in tools}\n    return tools\n\n# In _filter_mcp_results - O(1) lookup\ncached_tool = cache_service.get_tool_by_name(tool_name)\n```\n\n## Acceptance Criteria\n- [ ] ToolCacheService maintains name-indexed dict\n- [ ] `_filter_mcp_results()` uses O(1) dict lookup\n- [ ] Dict rebuilt on cache refresh\n- [ ] All unit tests pass\n- [ ] Add benchmark test comparing old vs new performance","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T01:49:55.722342789Z","updated_at":"2025-12-29T04:09:32.611153643Z","closed_at":"2025-12-29T04:09:32.611153643Z","close_reason":"Closed","labels":["performance"]}
{"id":"lettatoolsselector-jql","title":"[Test] Performance test: Tool attachment under load","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:28.165403794Z","updated_at":"2025-12-22T23:46:28.165403794Z","comments":[{"id":13,"issue_id":"lettatoolsselector-jql","author":"node","text":"## Purpose\n\nEnsure tool attachment scales and doesn't degrade under concurrent webhooks.\n\n## Test Scenario\n\n1. Simulate 10 concurrent webhook requests for different agents\n2. Measure: Response time for each request\n3. Measure: Total time to process all requests\n4. Assert: P95 response time \u003c 5 seconds\n5. Assert: No errors or timeouts\n\n## Acceptance Criteria\n\n- [ ] Test uses locust or similar load testing tool\n- [ ] Runs on-demand (not in regular CI)\n- [ ] Reports latency percentiles\n- [ ] Identifies bottlenecks if any\n\n## Technical Notes\n\n- Start with 10 concurrent, scale to 50\n- Monitor Letta API rate limits\n- Tag as \n\n---\nHuly Issue: LTSEL-26","created_at":"2025-12-22T23:46:28Z"}]}
{"id":"lettatoolsselector-kf7","title":"[Enforcement] Add pre-attach pruning to tool selector API","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:26.088411302Z","updated_at":"2025-12-23T03:26:57.73637653Z","comments":[{"id":1,"issue_id":"lettatoolsselector-kf7","author":"node","text":"## Problem\n\nTool selector API has MAX_TOTAL_TOOLS=20 but only enforces it loosely. Agents like Meridian accumulated 44 tools because pruning doesn't run proactively.\n\n## Solution\n\nBefore attaching new tools, prune existing tools to make room within the limit.\n\n## Acceptance Criteria\n\n- [ ] Before any attach operation, fetch current tool count\n- [ ] If current + new \u003e MAX_TOTAL_TOOLS, detach lowest-scored tools first\n- [ ] Protected tools are never detached (use PROTECTED_TOOLS env var)\n- [ ] Return detailed response showing what was pruned and why\n- [ ] Log pruning decisions for debugging\n\n## Technical Notes\n\n- Pruning order: oldest first, then lowest relevance score\n- Consider keeping tools attached in last 24h as \"recent\" protection\n- MAX_TOTAL_TOOLS is now 20\n\n---\nHuly Issue: LTSEL-7","created_at":"2025-12-22T23:46:26Z"}]}
{"id":"lettatoolsselector-lan","title":"[Refactor] Phase 4: Extract service layer - AgentService","description":"Extract Letta agent communication into a dedicated AgentService.\n\n## Depends On\n- lettatoolsselector-869 (Phase 1: Extract models)\n\n## Functions to Extract\n\n### AgentService (`services/agent_service.py`)\n\nMove these from api_server.py:\n\n| Function | Lines | Responsibility |\n|----------|-------|----------------|\n| `fetch_agent_info()` | 828-847 | Get agent name/details |\n| `fetch_agent_tools()` | 849-867 | Get agent's current tools |\n| `register_tool()` | 869-896 | Register tool with Letta |\n| `_send_trigger_message()` | 898-974 | Send trigger message to agent |\n| `trigger_agent_loop()` | 1037-1081 | Spawn background trigger |\n| `_emit_matrix_bridge_webhook()` | 976-1035 | Notify Matrix bridge |\n\n### Interface\n```python\nclass AgentService:\n    def __init__(self, letta_client, webhook_url: Optional[str] = None):\n        self.letta = letta_client\n        self.webhook_url = webhook_url\n    \n    async def get_agent_info(self, agent_id: str) -\u003e AgentInfo:\n        ...\n    \n    async def get_agent_tools(self, agent_id: str) -\u003e AgentToolSet:\n        ...\n    \n    async def register_tool(self, tool_name: str, server_name: str) -\u003e Tool:\n        ...\n    \n    async def trigger_loop(\n        self,\n        agent_id: str,\n        attached_tools: List[Tool],\n        query: Optional[str] = None\n    ) -\u003e TriggerResult:\n        ...\n    \n    async def notify_webhook(\n        self,\n        agent_id: str,\n        run_id: str,\n        tools: List[str],\n        query: str\n    ) -\u003e bool:\n        ...\n```\n\n### Consolidate with letta_sdk_client.py\nConsider merging functionality from `letta_sdk_client.py` into AgentService or having AgentService use it as underlying client.\n\n## Acceptance Criteria\n- [ ] AgentService class created\n- [ ] All agent communication functions moved\n- [ ] Webhook notification integrated\n- [ ] api_server.py uses AgentService\n- [ ] Unit tests with mocked Letta API\n- [ ] Integration tests still pass","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T19:37:54.612565801Z","updated_at":"2025-12-29T01:39:19.951426242Z"}
{"id":"lettatoolsselector-mna","title":"[Observability] Add Prometheus metrics to tool selector API","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:28:00.852182385Z","updated_at":"2025-12-23T03:28:00.852182385Z","comments":[{"id":54,"issue_id":"lettatoolsselector-mna","author":"node","text":"Synced from Beads: lettatoolsselector-sxk\n\n---\nHuly Issue: LTSEL-30","created_at":"2025-12-23T03:28:01Z"}]}
{"id":"lettatoolsselector-mu4","title":"[Observability] Emit structured events for tool attach/detach","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:26.527463806Z","updated_at":"2025-12-23T03:26:58.396924941Z","comments":[{"id":4,"issue_id":"lettatoolsselector-mu4","author":"node","text":"## Problem\n\nNo audit trail for tool changes. Debugging requires scraping logs from multiple containers.\n\n## Solution\n\nEmit structured events to a queue/stream whenever tools are attached or detached.\n\n## Acceptance Criteria\n\n- [ ] Event schema: {timestamp, agent_id, tool_id, tool_name, action, reason, source}\n- [ ] Events emitted from tool selector API on every attach/detach\n- [ ] Events written to Redis Stream or similar (low overhead)\n- [ ] Events include correlation ID for tracing webhook -\u003e attach flow\n\n## Technical Notes\n\n- Use Redis Streams for simplicity (XADD)\n- Keep 7 days of events by default\n- Consider also writing to structured log for Loki ingestion\n\n---\nHuly Issue: LTSEL-11","created_at":"2025-12-22T23:46:26Z"}]}
{"id":"lettatoolsselector-nav","title":"[Refactor] Phase 2: Extract service layer - ToolManager","description":"Extract tool management logic into a dedicated ToolManager service.\n\n## Status: In Progress\n- [x] Phase 1 complete: models.py created\n- [x] attach_tool, detach_tool, process_tools moved to tool_manager.py\n- [x] api_server.py delegates to tool_manager\n- [ ] _perform_tool_pruning extraction (see sub-issues)\n\n## Sub-Issues (Remaining Work)\n1. **lettatoolsselector-pmp**: Extract fetch_agent_tools to tool_manager\n2. **lettatoolsselector-9yr**: Extract config module for tool limits\n3. **lettatoolsselector-a6c**: Add search_tools callback to tool_manager\n4. **lettatoolsselector-c05**: Extract _perform_tool_pruning to tool_manager\n\n## Completed Functions\n\n| Function | Status | Location |\n|----------|--------|----------|\n| `attach_tool()` | Done | tool_manager.py |\n| `detach_tool()` | Done | tool_manager.py |\n| `process_tools()` | Done | tool_manager.py |\n| `is_letta_core_tool()` | Done | models.py |\n| `_perform_tool_pruning()` | Pending | See lettatoolsselector-c05 |\n| `process_matching_tool()` | Pending | Needs analysis |\n\n## Acceptance Criteria\n- [x] ToolManager module created (tool_manager.py)\n- [x] Core tool operations moved (attach/detach/process)\n- [x] api_server.py uses tool_manager\n- [x] Unit tests updated for tool_manager.configure()\n- [ ] _perform_tool_pruning moved\n- [ ] All 296+ unit tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T19:37:24.489690949Z","updated_at":"2025-12-29T01:39:19.556037201Z"}
{"id":"lettatoolsselector-pih","title":"[Perf] Eliminate redundant agent tools fetch in attach endpoint","description":"## Problem\nThe `/attach` endpoint calls `fetch_agent_tools()` twice - once at start, and again after pre-attach pruning.\n\n**Location:** `routes/tools.py:371-374, 527-543`\n\n```python\n# Line 371-374 - First fetch\nagent_name, current_agent_tools = await asyncio.gather(\n    _agent_service.fetch_agent_info(agent_id),\n    _tool_manager.fetch_agent_tools(agent_id)\n)\n\n# Line 528 - Redundant re-fetch after pruning\ncurrent_agent_tools = await _tool_manager.fetch_agent_tools(agent_id)\n```\n\n## Impact\n- **Latency:** 100-300ms wasted per attach request (extra Letta API call)\n- **Priority:** HIGH - common operation\n\n## Solution\nModify `perform_tool_pruning()` to return the updated tools list instead of requiring a re-fetch:\n\n```python\n# In tool_manager.py\nasync def perform_tool_pruning(...) -\u003e dict:\n    # ... pruning logic ...\n    return {\n        'success': True,\n        'details': {...},\n        'remaining_tools': remaining_tools  # Add this\n    }\n\n# In routes/tools.py\nprune_result = await _tool_manager.perform_tool_pruning(...)\nif prune_result.get('success'):\n    current_agent_tools = prune_result.get('remaining_tools', [])\n```\n\n## Acceptance Criteria\n- [ ] `perform_tool_pruning()` returns remaining tools\n- [ ] Attach endpoint uses returned tools instead of re-fetching\n- [ ] Only one `fetch_agent_tools()` call per attach request\n- [ ] All unit tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-29T01:49:30.385615524Z","updated_at":"2025-12-29T03:46:27.309411503Z","closed_at":"2025-12-29T03:46:27.309411503Z","close_reason":"Closed","labels":["performance"]}
{"id":"lettatoolsselector-pmp","title":"[Refactor] Extract fetch_agent_tools to tool_manager","description":"## Summary\nExtract `fetch_agent_tools` function to `tool_manager.py` to support `_perform_tool_pruning` extraction.\n\n## Current Location\n- `api_server.py:612-630`\n\n## Dependencies\n- Uses `USE_LETTA_SDK`, `get_letta_sdk_client()`, `http_session`, `LETTA_URL`, `HEADERS`\n- All these are already configured via `tool_manager.configure()`\n\n## Implementation\n1. Add `fetch_agent_tools()` to `tool_manager.py`\n2. Update `api_server.py` to delegate to `tool_manager.fetch_agent_tools()`\n3. Add unit tests\n\n## Acceptance Criteria\n- [ ] Function moved to tool_manager.py\n- [ ] api_server.py delegates to tool_manager\n- [ ] Unit tests pass\n- [ ] Integration tests pass\n\n## Parent Issue\nlettatoolsselector-nav","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T20:51:39.444968342Z","updated_at":"2025-12-29T01:39:11.351144792Z"}
{"id":"lettatoolsselector-ppg","title":"[SDK] Implement list_agent_tools with full pagination","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:27.934324694Z","updated_at":"2025-12-23T03:27:01.050807446Z"}
{"id":"lettatoolsselector-qgt","title":"[Refactor] Master: api_server.py modularization roadmap","description":"Master tracking issue for refactoring api_server.py from a 9,027 line monolith to a modular architecture.\n\n## Current State\n- **api_server.py**: 9,027 lines\n- **Routes**: 101 endpoints in one file\n- **Test coverage**: 8.8% on api_server.py\n- **Modularity**: Poor - most logic in one file\n\n## Target State\n- **api_server.py**: \u003c200 lines (app setup only)\n- **Routes**: Split into 8 blueprints\n- **Services**: 4 extracted service classes\n- **Models**: Dedicated model files\n- **Test coverage**: 70%+ on critical paths\n\n## Phases\n\n| Phase | Issue | Description | Priority |\n|-------|-------|-------------|----------|\n| 0 | lettatoolsselector-642 | Test coverage for critical paths | P1 |\n| 1 | lettatoolsselector-869 | Extract data models and types | P2 |\n| 2 | lettatoolsselector-nav | Extract ToolManager service | P2 |\n| 3 | lettatoolsselector-4w9 | Extract SearchService | P2 |\n| 4 | lettatoolsselector-lan | Extract AgentService | P2 |\n| 5 | lettatoolsselector-sbw | Extract route blueprints | P2 |\n| 6 | lettatoolsselector-ier | Dependency injection \u0026 app factory | P2 |\n\n## Dependency Graph\n```\nPhase 0 (Tests)\n    │\n    ▼\nPhase 1 (Models)\n    │\n    ├──────────┬──────────┐\n    ▼          ▼          ▼\nPhase 2    Phase 3    Phase 4\n(Tools)    (Search)   (Agent)\n    │          │          │\n    └──────────┴──────────┘\n               │\n               ▼\n          Phase 5 (Routes)\n               │\n               ▼\n          Phase 6 (DI/Factory)\n```\n\n## Success Metrics\n- [ ] api_server.py \u003c 500 lines\n- [ ] Critical path test coverage \u003e 80%\n- [ ] All existing tests pass\n- [ ] No API contract changes\n- [ ] Services are independently testable\n- [ ] New features easier to add\n\n## Notes\n- Each phase should be a separate PR\n- Run full test suite after each phase\n- Keep API contracts unchanged throughout\n- Document any breaking changes","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-28T19:38:55.088312878Z","updated_at":"2025-12-28T19:38:55.088312878Z"}
{"id":"lettatoolsselector-sbw","title":"[Refactor] Phase 5: Extract route handlers into blueprints","description":"Split the 101 route handlers from api_server.py into Flask Blueprints.\n\n## Depends On\n- lettatoolsselector-nav (Phase 2: ToolManager)\n- lettatoolsselector-4w9 (Phase 3: SearchService)\n- lettatoolsselector-lan (Phase 4: AgentService)\n\n## Route Groups to Extract\n\n### 1. Tools Blueprint (`routes/tools.py`) - 6 routes\n- POST /api/v1/tools/search\n- POST /api/v1/tools/search/rerank\n- GET /api/v1/tools\n- POST /api/v1/tools/attach\n- POST /api/v1/tools/prune\n- POST /api/v1/tools/sync\n- POST /api/v1/tools/refresh\n\n### 2. Config Blueprint (`routes/config.py`) - ~40 routes\n- /api/v1/config/reranker/*\n- /api/v1/config/embedding/*\n- /api/v1/config/weaviate/*\n- /api/v1/config/ollama/*\n- /api/v1/config/tool-selector/*\n- /api/v1/config/backup/*\n- /api/v1/config/validate/*\n- /api/v1/config/audit/*\n\n### 3. Search Blueprint (`routes/search.py`) - ~8 routes\n- /api/v1/search/parameter-schemas\n- /api/v1/search/parameter-sets/*\n- /api/v1/search/statistics\n- /api/v1/search/test\n\n### 4. Benchmark Blueprint (`routes/benchmark.py`) - ~8 routes\n- /api/v1/benchmark/query-sets/*\n- /api/v1/benchmark/runs\n\n### 5. Reranker Blueprint (`routes/reranker.py`) - ~6 routes\n- /api/v1/reranker/models/registry/*\n- /api/v1/rerank/compare\n- /api/v1/ab-comparison/*\n\n### 6. Maintenance Blueprint (`routes/maintenance.py`) - ~10 routes\n- /api/v1/maintenance/*\n- /api/v1/logs/*\n- /api/v1/weaviate/*\n\n### 7. Health Blueprint (`routes/health.py`) - 2 routes\n- GET /api/v1/health\n- GET /api/health\n\n### 8. Cost Control Blueprint (`routes/cost_control.py`) - ~8 routes\n- /api/v1/cost-control/*\n\n## File Structure\n```\nlettaaugment-source/\n├── routes/\n│   ├── __init__.py\n│   ├── tools.py\n│   ├── config.py\n│   ├── search.py\n│   ├── benchmark.py\n│   ├── reranker.py\n│   ├── maintenance.py\n│   ├── health.py\n│   └── cost_control.py\n├── app.py  # Flask app with blueprints registered\n└── main.py # Entry point\n```\n\n## Acceptance Criteria\n- [ ] All 101 routes moved to appropriate blueprints\n- [ ] api_server.py reduced to \u003c500 lines (app setup only)\n- [ ] Routes use injected services (ToolManager, SearchService, etc.)\n- [ ] All API tests still pass\n- [ ] No changes to API contracts","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-28T19:38:13.931841496Z","updated_at":"2025-12-29T01:39:20.361642416Z"}
{"id":"lettatoolsselector-t4d","title":"[Observability] Create Grafana dashboard for tool state","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-27T04:21:37.225895409Z","updated_at":"2025-12-27T04:21:37.225895409Z","comments":[{"id":221,"issue_id":"lettatoolsselector-t4d","author":"root","text":"Synced from Beads: lettatoolsselector-9fs\n\n---\nHuly Issue: LTSEL-56","created_at":"2025-12-27T04:21:37Z"}]}
{"id":"lettatoolsselector-t7g","title":"[Perf] Use persistent HTTP client for reranker calls","description":"## Problem\nUses synchronous `httpx.post()` which creates a new TCP connection per reranker request.\n\n**Location:** `weaviate_tool_search_with_reranking.py:274, 294`\n\n```python\n# Line 294\nresponse = httpx.post(RERANKER_URL, json=payload, timeout=RERANKER_TIMEOUT)\n```\n\n## Impact\n- **Latency:** 10-50ms per call in TCP connection overhead\n- **Priority:** MEDIUM - affects every reranked search\n\n## Solution\nUse a persistent `httpx.Client` with connection pooling:\n\n```python\n# Module-level persistent client\n_reranker_client: httpx.Client = None\n\ndef get_reranker_client() -\u003e httpx.Client:\n    global _reranker_client\n    if _reranker_client is None:\n        _reranker_client = httpx.Client(\n            timeout=RERANKER_TIMEOUT,\n            limits=httpx.Limits(max_keepalive_connections=10, max_connections=20)\n        )\n    return _reranker_client\n\ndef rerank_results(...):\n    client = get_reranker_client()\n    response = client.post(RERANKER_URL, json=payload)\n    # ...\n\n# Cleanup on shutdown\ndef close_reranker_client():\n    global _reranker_client\n    if _reranker_client:\n        _reranker_client.close()\n        _reranker_client = None\n```\n\n## Acceptance Criteria\n- [ ] Persistent httpx.Client used for reranker\n- [ ] Connection pooling configured\n- [ ] Client closed on app shutdown\n- [ ] All unit tests pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T01:50:08.273877005Z","updated_at":"2025-12-29T04:04:42.629636085Z","closed_at":"2025-12-29T04:04:42.629636085Z","close_reason":"Closed","labels":["performance"]}
{"id":"lettatoolsselector-tad","title":"[Refactor] Migrate config handlers to config blueprint","description":"## Goal\nMove the 3 remaining config handlers from api_server.py into routes/config.py with full implementations.\n\n## Handlers to Migrate\n- _validate_config_handler() - Line 783\n- _get_tool_selector_config_handler() - Line 819  \n- _update_tool_selector_config_handler() - Line 871\n\n## Pattern\n1. These handlers read/write config files - relatively self-contained\n2. Move implementation code directly into config.py routes\n3. Remove delegation pattern\n4. Update any tests mocking these handlers\n\n## Acceptance Criteria\n- [ ] All 3 handlers removed from api_server.py\n- [ ] routes/config.py contains full implementations\n- [ ] All unit tests pass\n- [ ] No new dependencies on api_server needed","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T00:42:57.262348909Z","updated_at":"2025-12-29T03:46:20.099969821Z","closed_at":"2025-12-29T03:46:20.099969821Z","close_reason":"Closed","labels":["refactor","services-layer"]}
{"id":"lettatoolsselector-trs","title":"[Enforcement] Add pre-attach pruning to tool selector API","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:03.021140072Z","updated_at":"2025-12-23T03:23:03.364825813Z","closed_at":"2025-12-23T03:23:03.364825813Z","close_reason":"Closed","comments":[{"id":25,"issue_id":"lettatoolsselector-trs","author":"node","text":"## Problem\n\nTool selector API has MAX_TOTAL_TOOLS=20 but only enforces it loosely. Agents like Meridian accumulated 44 tools because pruning doesn't run proactively.\n\n## Solution\n\nBefore attaching new tools, prune existing tools to make room within the limit.\n\n## Acceptance Criteria\n\n- [ ] Before any attach operation, fetch current tool count\n- [ ] If current + new \u003e MAX_TOTAL_TOOLS, detach lowest-scored tools first\n- [ ] Protected tools are never detached (use PROTECTED_TOOLS env var)\n- [ ] Return detailed response showing what was pruned and why\n- [ ] Log pruning decisions for debugging\n\n## Technical Notes\n\n- Pruning order: oldest first, then lowest relevance score\n- Consider keeping tools attached in last 24h as \"recent\" protection\n- MAX_TOTAL_TOOLS is now 20\n\n---\nHuly Issue: LTSEL-7","created_at":"2025-12-23T03:23:03Z"}]}
{"id":"lettatoolsselector-tzr","title":"[Enforcement] Define and document auto-attachment contract","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:27.069185687Z","updated_at":"2025-12-23T03:26:59.50752046Z","comments":[{"id":8,"issue_id":"lettatoolsselector-tzr","author":"node","text":"## Problem\n\nWebhook receiver and tool selector have different ideas about what fields are required, what keep_tools means, and how limits work.\n\n## Solution\n\nDefine a formal contract (JSON schema or Pydantic model) that both sides adhere to.\n\n## Acceptance Criteria\n\n- [ ] Document payload schema: query, agent_id, keep_tools, limit, min_score, protected_tools\n- [ ] Document response schema: success, attached, detached, preserved, errors\n- [ ] Document behavior: what happens when limits are exceeded, how protected tools work\n- [ ] Version the contract (v1) to allow future evolution\n- [ ] Both repos reference the same contract documentation\n\n## Technical Notes\n\n- Consider using OpenAPI/Swagger for formal spec\n- Publish contract in shared docs location or SDK repo\n\n---\nHuly Issue: LTSEL-9","created_at":"2025-12-22T23:46:27Z"}]}
{"id":"lettatoolsselector-ubk","title":"[Bugfix] Fix set iteration order mismatch in tool pruning result mapping","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:27.486559568Z","updated_at":"2025-12-23T03:27:00.257409133Z","comments":[{"id":11,"issue_id":"lettatoolsselector-ubk","author":"node","text":"## Problem\n\nIn  function (), there was a bug where detachment results could be incorrectly mapped to tool IDs due to set-to-list conversion happening twice.\n\n### Root Cause\n\n\n\nWhile Python 3.7+ maintains insertion order for sets in practice, converting a set to a list twice creates potential for mismatched mappings between async task results and tool IDs.\n\n## Impact\n\n- **Actual detachment operations worked correctly** - tools were being detached properly\n- **Logging/reporting was potentially incorrect** - wrong tool IDs could be logged as success/failure\n- **Debugging confusion** - audit logs may have shown incorrect tool names for detach operations\n\n## Solution\n\nConvert the set to a list **once** and reuse it:\n\n\n\n## Status\n\n**Fixed** - Applied to  lines 1208-1217. Container restarted to apply changes.\n\n## Related\n\n- Similar pattern in  function was already correct (iterates over list directly)\n- Relates to LTSEL-6 (SDK migration) and LTSEL-11 (structured events for attach/detach)\n\n---\nHuly Issue: LTSEL-27","created_at":"2025-12-22T23:46:27Z"}]}
{"id":"lettatoolsselector-ubl","title":"[Bugfix] Fix set iteration order mismatch in tool pruning result mapping","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:10.726358617Z","updated_at":"2025-12-23T03:23:11.118829205Z","closed_at":"2025-12-23T03:23:11.118829205Z","close_reason":"Closed","comments":[{"id":35,"issue_id":"lettatoolsselector-ubl","author":"node","text":"## Problem\n\nIn  function (), there was a bug where detachment results could be incorrectly mapped to tool IDs due to set-to-list conversion happening twice.\n\n### Root Cause\n\n\n\nWhile Python 3.7+ maintains insertion order for sets in practice, converting a set to a list twice creates potential for mismatched mappings between async task results and tool IDs.\n\n## Impact\n\n- **Actual detachment operations worked correctly** - tools were being detached properly\n- **Logging/reporting was potentially incorrect** - wrong tool IDs could be logged as success/failure\n- **Debugging confusion** - audit logs may have shown incorrect tool names for detach operations\n\n## Solution\n\nConvert the set to a list **once** and reuse it:\n\n\n\n## Status\n\n**Fixed** - Applied to  lines 1208-1217. Container restarted to apply changes.\n\n## Related\n\n- Similar pattern in  function was already correct (iterates over list directly)\n- Relates to LTSEL-6 (SDK migration) and LTSEL-11 (structured events for attach/detach)\n\n---\nHuly Issue: LTSEL-27","created_at":"2025-12-23T03:23:10Z"}]}
{"id":"lettatoolsselector-ufs","title":"[Perf] Reduce excessive logging in hot paths","description":"## Problem\nDEBUG and INFO level logs on every request, even in production. String formatting happens regardless of log level.\n\n**Location:** Throughout `routes/tools.py`, `tool_manager.py`\n\n```python\n# Line 205 in routes/tools.py\nlogger.info(\"Received request for /api/v1/tools/search\")\n\n# Line 247\nlogger.info(f\"Search: {len(results)} total, {len(filtered_results)} after MCP filtering\")\n```\n\n## Impact\n- **Latency:** 1-5ms cumulative per request in string formatting and I/O\n- **Priority:** LOW-MEDIUM\n\n## Solution\nUse lazy formatting and reduce INFO logs in hot paths:\n\n```python\n# Use lazy formatting\nlogger.debug(\"Search: %d total, %d after filtering\", len(results), len(filtered_results))\n\n# Or check level before formatting\nif logger.isEnabledFor(logging.DEBUG):\n    logger.debug(f\"Search: {len(results)} total, {len(filtered_results)} after MCP filtering\")\n```\n\n## Guidelines\n- Request entry/exit: DEBUG level (not INFO)\n- Errors: ERROR level\n- Significant events (attach/prune success): INFO level\n- Detailed diagnostics: DEBUG level\n\n## Acceptance Criteria\n- [ ] Hot path logs reduced to DEBUG level\n- [ ] Lazy formatting used where appropriate\n- [ ] No string formatting when log level disabled\n- [ ] All unit tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-29T01:50:34.202369804Z","updated_at":"2025-12-29T01:50:34.202369804Z","labels":["performance"]}
{"id":"lettatoolsselector-v1l","title":"[Code Quality] Fix unbound variable warnings for get_letta_sdk_client","description":"The `get_letta_sdk_client` function shows 'possibly unbound' warnings at multiple locations.\n\n## Affected Lines\n- Line 255\n- Line 314\n- Line 369\n- Line 833\n- Line 854\n- Line 874\n\n## Root Cause\nThe function is likely conditionally imported or defined, causing the static analyzer to flag it as potentially undefined.\n\n## Possible Solutions\n1. Move import to top of file unconditionally\n2. Add explicit None check before use\n3. Use a try/except import pattern with proper fallback\n4. Add type: ignore comments if intentional (not recommended)\n\n## Acceptance Criteria\n- [ ] No 'possibly unbound' warnings for get_letta_sdk_client\n- [ ] Function is reliably available where used\n- [ ] Graceful handling if SDK client unavailable","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-28T17:13:20.013706888Z","updated_at":"2025-12-28T17:13:20.013706888Z"}
{"id":"lettatoolsselector-v66","title":"[Test] Integration test: Tool count never exceeds MAX_TOTAL_TOOLS","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:06.562903106Z","updated_at":"2025-12-23T03:23:06.933264976Z","closed_at":"2025-12-23T03:23:06.933264976Z","close_reason":"Closed","comments":[{"id":30,"issue_id":"lettatoolsselector-v66","author":"node","text":"## Purpose\n\nRegression guard to ensure tool limits are enforced end-to-end.\n\n## Test Scenario\n\n1. Create test agent with MAX_TOTAL_TOOLS-1 tools attached\n2. Trigger webhook with query that matches 5 tools\n3. Assert: Agent tool count \u003c= MAX_TOTAL_TOOLS after operation\n4. Assert: Response includes pruned tools if any were removed\n\n## Acceptance Criteria\n\n- [ ] Test runs in CI on every PR\n- [ ] Uses real tool selector API (integration test)\n- [ ] Cleans up test agent after run\n- [ ] Fails if agent exceeds limit\n\n## Technical Notes\n\n- Use pytest with fixtures for agent setup/teardown\n- May need test-specific MAX_TOTAL_TOOLS value (e.g., 5) for fast testing\n- Tag as \n\n---\nHuly Issue: LTSEL-19","created_at":"2025-12-23T03:23:06Z"}]}
{"id":"lettatoolsselector-vc5","title":"[Test] Contract test: Tool selector API returns valid response","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:15.201745315Z","updated_at":"2025-12-23T03:23:15.201745315Z","comments":[{"id":39,"issue_id":"lettatoolsselector-vc5","author":"node","text":"## Purpose\n\nGuard against tool selector API returning unexpected response format.\n\n## Test Scenario\n\n1. Send valid attach request to tool selector API\n2. Capture response\n3. Assert: Response matches documented contract schema\n4. Assert: All required fields present (success, details.attached, details.detached)\n\n## Acceptance Criteria\n\n- [ ] Test validates response structure\n- [ ] Covers success and error responses\n- [ ] Fails if response doesn't match contract\n- [ ] Runs in tool-selector CI\n\n## Technical Notes\n\n- Can use real API or mocked\n- Reference contract from LTSEL-9\n- Tag as \n\n---\nHuly Issue: LTSEL-24","created_at":"2025-12-23T03:23:15Z"}]}
{"id":"lettatoolsselector-vly","title":"[Test] Performance test: Tool attachment under load","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:13.917942507Z","updated_at":"2025-12-23T03:23:13.917942507Z","comments":[{"id":37,"issue_id":"lettatoolsselector-vly","author":"node","text":"## Purpose\n\nEnsure tool attachment scales and doesn't degrade under concurrent webhooks.\n\n## Test Scenario\n\n1. Simulate 10 concurrent webhook requests for different agents\n2. Measure: Response time for each request\n3. Measure: Total time to process all requests\n4. Assert: P95 response time \u003c 5 seconds\n5. Assert: No errors or timeouts\n\n## Acceptance Criteria\n\n- [ ] Test uses locust or similar load testing tool\n- [ ] Runs on-demand (not in regular CI)\n- [ ] Reports latency percentiles\n- [ ] Identifies bottlenecks if any\n\n## Technical Notes\n\n- Start with 10 concurrent, scale to 50\n- Monitor Letta API rate limits\n- Tag as \n\n---\nHuly Issue: LTSEL-26","created_at":"2025-12-23T03:23:14Z"}]}
{"id":"lettatoolsselector-vu4","title":"[SDK] Migrate tool-selector to use shared SDK","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:26.3962366Z","updated_at":"2025-12-23T03:26:58.229633047Z","comments":[{"id":3,"issue_id":"lettatoolsselector-vu4","author":"node","text":"## Problem\n\nTool selector has its own  and  that duplicate SDK functionality.\n\n## Solution\n\nReplace local implementations with SDK imports.\n\n## Acceptance Criteria\n\n- [ ] Add  to \n- [ ] Replace  helpers with SDK imports\n- [ ] Replace  with SDK imports\n- [ ] All existing tests still pass\n- [ ] No functional changes to tool selection behavior\n\n## Technical Notes\n\n- Worker service models may need adjustment\n- Keep API-specific logic in the repo, move generic logic to SDK\n\n---\nHuly Issue: LTSEL-6","created_at":"2025-12-22T23:46:26Z"}]}
{"id":"lettatoolsselector-wlj","title":"[Refactor] Migrate evaluation/analytics handlers to evaluation blueprint","description":"## Goal\nMove 7 evaluation-related handlers from api_server.py into routes/evaluation.py with full implementations.\n\n## Handlers to Migrate\n### Core Evaluation (4)\n- _submit_evaluation_handler() - Line 1216\n- _get_evaluations_handler() - Line 1250\n- _get_analytics_handler() - Line 1273\n- _compare_rerank_handler() - Line 1305\n\n### A/B Comparison (3)\n- _run_ab_comparison_handler() - Line 1847\n- _get_ab_results_handler() - Line 1897\n- _get_ab_result_by_id_handler() - Line 1956\n\n## Services Needed\nMay need services/evaluation.py for:\n- File I/O for evaluation persistence\n- Metrics calculation utilities\n- A/B statistical comparison functions\n\n## Pattern\n1. Create evaluation service if shared utilities needed\n2. Move handler implementations into evaluation.py blueprint\n3. Configure services via blueprint configure() method\n4. Remove old handlers from api_server.py\n\n## Acceptance Criteria\n- [ ] All 7 handlers removed from api_server.py\n- [ ] routes/evaluation.py contains full implementations\n- [ ] Service layer created if needed for shared utilities\n- [ ] All unit tests pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-29T00:43:06.516457468Z","updated_at":"2025-12-29T01:21:05.512504219Z","closed_at":"2025-12-29T01:21:05.512504219Z","close_reason":"Migrated all 7 evaluation handlers and 12 helper functions to routes/evaluation.py. Blueprint is now fully self-contained (878 lines). api_server.py reduced to 2,408 lines with only 4 handlers remaining.","labels":["refactor","services-layer"]}
{"id":"lettatoolsselector-x0j","title":"[Enforcement] Add PROTECTED_TOOLS support to tool selector API","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:09.617990903Z","updated_at":"2025-12-23T03:23:09.966249296Z","closed_at":"2025-12-23T03:23:09.966249296Z","close_reason":"Closed","comments":[{"id":34,"issue_id":"lettatoolsselector-x0j","author":"node","text":"## Problem\n\nProtected tools (find_agents, find_tools) logic only exists in webhook receiver. Tool selector API should also respect protected tools during pruning.\n\n## Solution\n\nAdd PROTECTED_TOOLS env var to tool selector API and respect it during all detach operations.\n\n## Acceptance Criteria\n\n- [ ] PROTECTED_TOOLS env var (comma-separated tool names)\n- [ ] Before any detach, check if tool is protected\n- [ ] Never detach protected tools even if over limit\n- [ ] Warn if agent is over limit but can't prune due to protected tools\n- [ ] Document protected tools in compose.yaml\n\n## Technical Notes\n\n- Default protected tools: find_agents, find_tools, send_message\n- Allow override via env var\n- Lookup by name, not ID (IDs can change)\n\n---\nHuly Issue: LTSEL-10","created_at":"2025-12-23T03:23:09Z"}]}
{"id":"lettatoolsselector-xde","title":"[Observability] Add health check endpoint with tool state summary","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:27.198050175Z","updated_at":"2025-12-23T03:26:59.808622912Z","comments":[{"id":9,"issue_id":"lettatoolsselector-xde","author":"node","text":"## Problem\n\nCurrent health endpoint only returns basic status. No way to quickly check if tool management is working correctly.\n\n## Solution\n\nEnhance health endpoint to include tool state summary.\n\n## Acceptance Criteria\n\n- [ ] Health endpoint returns: status, version, config summary\n- [ ] Include: MAX_TOTAL_TOOLS, PROTECTED_TOOLS list\n- [ ] Include: total_agents_tracked, agents_over_limit count\n- [ ] Include: last_attach_timestamp, last_prune_timestamp\n- [ ] Separate deep health check for dependencies (Letta API, Weaviate)\n\n## Technical Notes\n\n- Keep lightweight for frequent polling\n- Deep health check on separate endpoint (/health/deep)\n\n---\nHuly Issue: LTSEL-14","created_at":"2025-12-22T23:46:27Z"}]}
{"id":"lettatoolsselector-xoz","title":"[Config] Document operational runbooks","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-23T03:23:18.051512948Z","updated_at":"2025-12-23T03:23:18.051512948Z","comments":[{"id":43,"issue_id":"lettatoolsselector-xoz","author":"node","text":"## Problem\n\nNo documentation for common ops tasks. Each debugging session rediscovers the same steps.\n\n## Solution\n\nCreate runbooks for common operations.\n\n## Acceptance Criteria\n\n- [ ] Runbook: How to change MAX_TOTAL_TOOLS limit\n- [ ] Runbook: How to add/remove protected tools\n- [ ] Runbook: How to manually prune an agent's tools\n- [ ] Runbook: How to debug \"tool not attaching\" issues\n- [ ] Runbook: How to check tool selector health\n- [ ] Store in docs/ directory within repo\n\n## Technical Notes\n\n- Include exact commands with expected outputs\n- Link to relevant compose services and env vars\n- Keep updated as architecture evolves\n\n---\nHuly Issue: LTSEL-18","created_at":"2025-12-23T03:23:18Z"}]}
{"id":"lettatoolsselector-xxx","title":"[Enforcement] Add PROTECTED_TOOLS support to tool selector API","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-22T23:46:27.358861104Z","updated_at":"2025-12-23T03:26:59.997463048Z","comments":[{"id":10,"issue_id":"lettatoolsselector-xxx","author":"node","text":"## Problem\n\nProtected tools (find_agents, find_tools) logic only exists in webhook receiver. Tool selector API should also respect protected tools during pruning.\n\n## Solution\n\nAdd PROTECTED_TOOLS env var to tool selector API and respect it during all detach operations.\n\n## Acceptance Criteria\n\n- [ ] PROTECTED_TOOLS env var (comma-separated tool names)\n- [ ] Before any detach, check if tool is protected\n- [ ] Never detach protected tools even if over limit\n- [ ] Warn if agent is over limit but can't prune due to protected tools\n- [ ] Document protected tools in compose.yaml\n\n## Technical Notes\n\n- Default protected tools: find_agents, find_tools, send_message\n- Allow override via env var\n- Lookup by name, not ID (IDs can change)\n\n---\nHuly Issue: LTSEL-10","created_at":"2025-12-22T23:46:27Z"}]}
